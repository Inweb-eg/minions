/**
 * GapDetector
 * -----------
 * Analyzes projects to find missing features, endpoints, pages, tests, and documentation.
 *
 * Auto-generated by Minions Evolution Pipeline
 */

import EventEmitter from 'events';
import fs from 'fs/promises';
import path from 'path';

// Gap types
export const GapType = {
  BACKEND_ENDPOINT: 'backend:endpoint',
  BACKEND_MODEL: 'backend:model',
  BACKEND_SERVICE: 'backend:service',
  FRONTEND_PAGE: 'frontend:page',
  FRONTEND_COMPONENT: 'frontend:component',
  TEST_UNIT: 'test:unit',
  TEST_INTEGRATION: 'test:integration',
  DOCUMENTATION: 'documentation',
  CONFIGURATION: 'configuration'
};

// Gap priority levels
export const Priority = {
  CRITICAL: 1,
  HIGH: 2,
  MEDIUM: 3,
  LOW: 4
};

export class GapDetector extends EventEmitter {
  constructor(config = {}) {
    super();
    this.config = config;
    this.gaps = [];
    this.gapId = 0;
  }

  /**
   * Full gap detection for a project
   * @param {object} project - Project to analyze
   */
  async detect(project) {
    try {
      this.gaps = [];
      const sourcePath = project.sourcePath;

      // Detect different types of gaps
      const backendGaps = await this.detectBackendGaps(sourcePath, project);
      const frontendGaps = await this.detectFrontendGaps(sourcePath, project);
      const testGaps = await this.detectTestGaps(sourcePath, project);
      const docGaps = await this.detectDocumentationGaps(sourcePath, project);

      this.gaps = [
        ...backendGaps,
        ...frontendGaps,
        ...testGaps,
        ...docGaps
      ];

      return this.gaps;
    } catch (error) {
      this.emit('error', { method: 'detect', error: error.message });
      throw error;
    }
  }

  /**
   * Detect missing backend endpoints and models
   * @param {string} sourcePath - Path to project source
   * @param {object} project - Project info
   */
  async detectBackendGaps(sourcePath, project) {
    const gaps = [];

    try {
      // Check for routes directory
      const routesPath = path.join(sourcePath, 'src', 'routes');
      try {
        const routes = await fs.readdir(routesPath);

        // Check for common missing endpoints
        const expectedRoutes = ['users', 'auth', 'health'];
        for (const expected of expectedRoutes) {
          const exists = routes.some(r => r.toLowerCase().includes(expected));
          if (!exists) {
            gaps.push(this._createGap({
              type: GapType.BACKEND_ENDPOINT,
              description: `Missing ${expected} routes`,
              location: routesPath,
              priority: expected === 'auth' ? Priority.CRITICAL : Priority.HIGH
            }));
          }
        }
      } catch (e) {
        // No routes directory
      }

      // Check for models directory
      const modelsPath = path.join(sourcePath, 'src', 'models');
      try {
        await fs.access(modelsPath);
      } catch (e) {
        gaps.push(this._createGap({
          type: GapType.BACKEND_MODEL,
          description: 'No models directory found',
          location: path.join(sourcePath, 'src'),
          priority: Priority.MEDIUM
        }));
      }

      // Check for services directory
      const servicesPath = path.join(sourcePath, 'src', 'services');
      try {
        await fs.access(servicesPath);
      } catch (e) {
        gaps.push(this._createGap({
          type: GapType.BACKEND_SERVICE,
          description: 'No services directory found',
          location: path.join(sourcePath, 'src'),
          priority: Priority.MEDIUM
        }));
      }

    } catch (error) {
      // Continue with other checks
    }

    return gaps;
  }

  /**
   * Detect missing frontend pages and components
   * @param {string} sourcePath - Path to project source
   * @param {object} project - Project info
   */
  async detectFrontendGaps(sourcePath, project) {
    const gaps = [];

    try {
      // Check for pages directory (Next.js pattern)
      const pagesPath = path.join(sourcePath, 'pages');
      const appPath = path.join(sourcePath, 'app');
      const srcPagesPath = path.join(sourcePath, 'src', 'pages');

      let hasPages = false;
      for (const p of [pagesPath, appPath, srcPagesPath]) {
        try {
          await fs.access(p);
          hasPages = true;
          break;
        } catch (e) {
          // Continue checking
        }
      }

      if (!hasPages && project.framework?.includes('Next.js')) {
        gaps.push(this._createGap({
          type: GapType.FRONTEND_PAGE,
          description: 'No pages directory found',
          location: sourcePath,
          priority: Priority.HIGH
        }));
      }

      // Check for components directory
      const componentsPath = path.join(sourcePath, 'src', 'components');
      const componentsPath2 = path.join(sourcePath, 'components');

      let hasComponents = false;
      for (const p of [componentsPath, componentsPath2]) {
        try {
          await fs.access(p);
          hasComponents = true;
          break;
        } catch (e) {
          // Continue checking
        }
      }

      if (!hasComponents) {
        gaps.push(this._createGap({
          type: GapType.FRONTEND_COMPONENT,
          description: 'No components directory found',
          location: sourcePath,
          priority: Priority.MEDIUM
        }));
      }

    } catch (error) {
      // Continue with other checks
    }

    return gaps;
  }

  /**
   * Detect missing tests
   * @param {string} sourcePath - Path to project source
   * @param {object} project - Project info
   */
  async detectTestGaps(sourcePath, project) {
    const gaps = [];

    try {
      // Check for test directories
      const testPaths = [
        path.join(sourcePath, 'tests'),
        path.join(sourcePath, 'test'),
        path.join(sourcePath, '__tests__'),
        path.join(sourcePath, 'src', '__tests__')
      ];

      let hasTests = false;
      for (const p of testPaths) {
        try {
          await fs.access(p);
          hasTests = true;
          break;
        } catch (e) {
          // Continue checking
        }
      }

      if (!hasTests) {
        gaps.push(this._createGap({
          type: GapType.TEST_UNIT,
          description: 'No tests directory found',
          location: sourcePath,
          priority: Priority.HIGH
        }));
      }

      // Check for test configuration
      const jestConfigPaths = ['jest.config.js', 'jest.config.ts', 'jest.config.json'];
      let hasTestConfig = false;

      for (const configFile of jestConfigPaths) {
        try {
          await fs.access(path.join(sourcePath, configFile));
          hasTestConfig = true;
          break;
        } catch (e) {
          // Continue checking
        }
      }

      if (!hasTestConfig && hasTests) {
        gaps.push(this._createGap({
          type: GapType.CONFIGURATION,
          description: 'No Jest configuration found',
          location: sourcePath,
          priority: Priority.LOW
        }));
      }

    } catch (error) {
      // Continue with other checks
    }

    return gaps;
  }

  /**
   * Detect missing documentation
   * @param {string} sourcePath - Path to project source
   * @param {object} project - Project info
   */
  async detectDocumentationGaps(sourcePath, project) {
    const gaps = [];

    try {
      // Check for README
      try {
        await fs.access(path.join(sourcePath, 'README.md'));
      } catch (e) {
        gaps.push(this._createGap({
          type: GapType.DOCUMENTATION,
          description: 'No README.md found',
          location: sourcePath,
          priority: Priority.MEDIUM
        }));
      }

      // Check for docs directory
      try {
        await fs.access(path.join(sourcePath, 'docs'));
      } catch (e) {
        gaps.push(this._createGap({
          type: GapType.DOCUMENTATION,
          description: 'No docs directory found',
          location: sourcePath,
          priority: Priority.LOW
        }));
      }

    } catch (error) {
      // Continue with other checks
    }

    return gaps;
  }

  /**
   * Prioritize gaps by importance
   * @param {array} gaps - List of gaps
   */
  async prioritize(gaps) {
    // Sort by priority (lower number = higher priority)
    return [...gaps].sort((a, b) => a.priority - b.priority);
  }

  /**
   * Save gaps to a file
   * @param {string} outputPath - Path to save gaps
   */
  async save(outputPath) {
    try {
      await fs.writeFile(outputPath, JSON.stringify(this.gaps, null, 2));
      return { success: true, path: outputPath };
    } catch (error) {
      this.emit('error', { method: 'save', error: error.message });
      throw error;
    }
  }

  /**
   * Create a gap object
   * @private
   */
  _createGap({ type, description, location, priority }) {
    return {
      id: `gap-${++this.gapId}`,
      type,
      description,
      location,
      priority,
      status: 'pending',
      detectedAt: new Date().toISOString()
    };
  }

  async shutdown() {
    this.gaps = [];
    this.removeAllListeners();
  }
}

export default GapDetector;
