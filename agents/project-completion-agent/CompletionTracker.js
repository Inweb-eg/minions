/**
 * CompletionTracker
 * -----------------
 * Calculates and tracks completion percentage with history.
 *
 * Auto-generated by Minions Evolution Pipeline
 */

import EventEmitter from 'events';
import fs from 'fs/promises';
import path from 'path';

export class CompletionTracker extends EventEmitter {
  constructor(config = {}) {
    super();
    this.config = config;
    this.progressData = new Map();
  }

  /**
   * Calculate completion percentage for a project
   * @param {string} projectName - Name of the project
   */
  async calculate(projectName) {
    try {
      const projectData = this.progressData.get(projectName) || {
        totalGaps: 0,
        resolvedGaps: 0,
        percentage: 0
      };

      // If no gaps were found, consider it 100% complete for now
      // The actual gap count comes from GapDetector
      if (projectData.totalGaps === 0) {
        return 100;
      }

      const percentage = Math.round(
        (projectData.resolvedGaps / projectData.totalGaps) * 100
      );

      projectData.percentage = percentage;
      projectData.lastCalculated = new Date().toISOString();
      this.progressData.set(projectName, projectData);

      return percentage;
    } catch (error) {
      this.emit('error', { method: 'calculate', error: error.message });
      throw error;
    }
  }

  /**
   * Update progress after a gap is resolved
   * @param {string} projectName - Name of the project
   * @param {object} update - Update data
   */
  async updateProgress(projectName, update) {
    try {
      const projectData = this.progressData.get(projectName) || {
        totalGaps: 0,
        resolvedGaps: 0,
        percentage: 0,
        history: []
      };

      if (update.gapResolved) {
        projectData.resolvedGaps++;
      }

      if (update.totalGaps !== undefined) {
        projectData.totalGaps = update.totalGaps;
      }

      // Recalculate percentage
      if (projectData.totalGaps > 0) {
        projectData.percentage = Math.round(
          (projectData.resolvedGaps / projectData.totalGaps) * 100
        );
      }

      // Add to history
      projectData.history.push({
        timestamp: new Date().toISOString(),
        percentage: projectData.percentage,
        resolvedGaps: projectData.resolvedGaps,
        iteration: update.iteration
      });

      // Keep only last 100 history entries
      if (projectData.history.length > 100) {
        projectData.history = projectData.history.slice(-100);
      }

      projectData.lastUpdated = new Date().toISOString();
      this.progressData.set(projectName, projectData);

      return {
        success: true,
        percentage: projectData.percentage,
        resolvedGaps: projectData.resolvedGaps,
        totalGaps: projectData.totalGaps
      };
    } catch (error) {
      this.emit('error', { method: 'updateProgress', error: error.message });
      throw error;
    }
  }

  /**
   * Set the total number of gaps for a project
   * @param {string} projectName - Name of the project
   * @param {number} totalGaps - Total gaps detected
   */
  async setTotalGaps(projectName, totalGaps) {
    const projectData = this.progressData.get(projectName) || {
      totalGaps: 0,
      resolvedGaps: 0,
      percentage: 0,
      history: []
    };

    projectData.totalGaps = totalGaps;
    this.progressData.set(projectName, projectData);

    return { success: true, totalGaps };
  }

  /**
   * Get progress history for a project
   * @param {string} projectName - Name of the project
   * @param {number} days - Number of days to retrieve (0 = all)
   */
  async getHistory(projectName, days = 0) {
    try {
      const projectData = this.progressData.get(projectName);
      if (!projectData || !projectData.history) {
        return [];
      }

      if (days === 0) {
        return projectData.history;
      }

      const cutoff = new Date();
      cutoff.setDate(cutoff.getDate() - days);

      return projectData.history.filter(entry => {
        return new Date(entry.timestamp) >= cutoff;
      });
    } catch (error) {
      this.emit('error', { method: 'getHistory', error: error.message });
      throw error;
    }
  }

  /**
   * Get current progress for a project
   * @param {string} projectName - Name of the project
   */
  getProgress(projectName) {
    return this.progressData.get(projectName) || {
      totalGaps: 0,
      resolvedGaps: 0,
      percentage: 0,
      history: []
    };
  }

  /**
   * Save progress to a file
   * @param {string} outputPath - Path to save state
   */
  async save(outputPath) {
    try {
      const data = {
        projects: Object.fromEntries(this.progressData),
        savedAt: new Date().toISOString()
      };

      await fs.writeFile(outputPath, JSON.stringify(data, null, 2));
      return { success: true, path: outputPath };
    } catch (error) {
      this.emit('error', { method: 'save', error: error.message });
      throw error;
    }
  }

  /**
   * Load progress from a file
   * @param {string} inputPath - Path to load state from
   */
  async load(inputPath) {
    try {
      const data = await fs.readFile(inputPath, 'utf-8');
      const parsed = JSON.parse(data);

      if (parsed.projects) {
        this.progressData = new Map(Object.entries(parsed.projects));
      }

      return { success: true };
    } catch (error) {
      if (error.code === 'ENOENT') {
        return { success: true, note: 'No existing state' };
      }
      this.emit('error', { method: 'load', error: error.message });
      throw error;
    }
  }

  async shutdown() {
    this.progressData.clear();
    this.removeAllListeners();
  }
}

export default CompletionTracker;
