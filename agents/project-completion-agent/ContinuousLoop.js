/**
 * ContinuousLoop
 * --------------
 * Manages the autonomous analyze-build-test-fix loop until completion.
 *
 * Auto-generated by Minions Evolution Pipeline
 */

import EventEmitter from 'events';

// Loop states
export const LoopState = {
  IDLE: 'IDLE',
  RUNNING: 'RUNNING',
  PAUSED: 'PAUSED',
  STOPPED: 'STOPPED',
  COMPLETED: 'COMPLETED',
  ERROR: 'ERROR'
};

export class ContinuousLoop extends EventEmitter {
  constructor(config = {}) {
    super();
    this.config = {
      maxIterations: config.maxIterations || 50,
      delayBetweenIterations: config.delayBetweenIterations || 1000,
      targetCompletion: config.targetCompletion || 100,
      ...config
    };

    this.state = LoopState.IDLE;
    this.currentIteration = 0;
    this.isPaused = false;
    this.shouldStop = false;
  }

  /**
   * Start the continuous loop
   * @param {object} context - Loop context (project, gaps, etc.)
   */
  async start(context = {}) {
    if (this.state === LoopState.RUNNING) {
      throw new Error('Loop is already running');
    }

    this.state = LoopState.RUNNING;
    this.currentIteration = 0;
    this.isPaused = false;
    this.shouldStop = false;

    this.emit('started', { context });

    return { success: true };
  }

  /**
   * Pause the loop
   */
  async pause() {
    if (this.state !== LoopState.RUNNING) {
      return { success: true, message: 'Not running' };
    }

    this.isPaused = true;
    this.state = LoopState.PAUSED;

    this.emit('paused', { iteration: this.currentIteration });

    return { success: true };
  }

  /**
   * Resume the loop
   */
  async resume() {
    if (this.state !== LoopState.PAUSED) {
      throw new Error('Cannot resume - not paused');
    }

    this.isPaused = false;
    this.state = LoopState.RUNNING;

    this.emit('resumed', { iteration: this.currentIteration });

    return { success: true };
  }

  /**
   * Stop the loop
   */
  async stop() {
    this.shouldStop = true;
    this.state = LoopState.STOPPED;

    this.emit('stopped', {
      iteration: this.currentIteration,
      reason: 'Manual stop'
    });

    return { success: true };
  }

  /**
   * Run a single iteration of the loop
   * @param {object} context - Iteration context
   */
  async runIteration(context = {}) {
    if (this.isPaused || this.shouldStop) {
      return { success: false, reason: 'Loop is paused or stopped' };
    }

    this.currentIteration++;

    this.emit('iteration:started', {
      iteration: this.currentIteration,
      context
    });

    try {
      // The actual work is done by the parent agent
      // This just manages the loop state

      const result = {
        success: true,
        iteration: this.currentIteration
      };

      this.emit('iteration:completed', result);

      // Delay between iterations
      await this._delay(this.config.delayBetweenIterations);

      return result;
    } catch (error) {
      this.state = LoopState.ERROR;
      this.emit('error', {
        iteration: this.currentIteration,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Check if target completion is reached
   * @param {number} currentCompletion - Current completion percentage
   */
  checkCompletion(currentCompletion) {
    const isComplete = currentCompletion >= this.config.targetCompletion;
    const maxReached = this.currentIteration >= this.config.maxIterations;

    if (isComplete) {
      this.state = LoopState.COMPLETED;
      this.emit('completed', {
        iteration: this.currentIteration,
        completion: currentCompletion
      });
    }

    if (maxReached && !isComplete) {
      this.emit('max-iterations-reached', {
        iteration: this.currentIteration,
        completion: currentCompletion
      });
    }

    return {
      isComplete,
      maxReached,
      shouldContinue: !isComplete && !maxReached && !this.isPaused && !this.shouldStop
    };
  }

  /**
   * Get current loop status
   */
  getStatus() {
    return {
      state: this.state,
      currentIteration: this.currentIteration,
      maxIterations: this.config.maxIterations,
      isPaused: this.isPaused,
      targetCompletion: this.config.targetCompletion
    };
  }

  /**
   * Reset the loop
   */
  reset() {
    this.state = LoopState.IDLE;
    this.currentIteration = 0;
    this.isPaused = false;
    this.shouldStop = false;
  }

  /**
   * Internal delay helper
   * @private
   */
  _delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async shutdown() {
    await this.stop();
    this.removeAllListeners();
  }
}

export default ContinuousLoop;
