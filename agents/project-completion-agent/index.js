/**
 * Minions - ProjectCompletionAgent (Lucy)
 * ========================================
 * Named after Lucy Wilde - the Self-Improvement Engine.
 * Runs autonomous completion loops until a project reaches 100% completion.
 *
 * Auto-generated by Minions Evolution Pipeline
 */

import EventEmitter from 'events';
import path from 'path';
import fs from 'fs/promises';
import { createLogger } from '../../foundation/common/logger.js';
import { getEventBus } from '../../foundation/event-bus/AgentEventBus.js';
import { EventTypes } from '../../foundation/event-bus/eventTypes.js';
import { getPlanExecutor } from '../nefario-agent/PlanExecutor.js';

import GapDetector from './GapDetector.js';
import CompletionTracker from './CompletionTracker.js';
import ContinuousLoop from './ContinuousLoop.js';

// Agent States
export const AgentState = {
  IDLE: 'IDLE',
  INITIALIZING: 'INITIALIZING',
  ANALYZING: 'ANALYZING',
  PLANNING: 'PLANNING',
  BUILDING: 'BUILDING',
  TESTING: 'TESTING',
  FIXING: 'FIXING',
  VERIFYING: 'VERIFYING',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  ERROR: 'ERROR',
  SHUTDOWN: 'SHUTDOWN'
};

// Event Types
export const CompletionEvents = {
  COMPLETION_START: 'completion:start',
  COMPLETION_STARTED: 'completion:started',
  COMPLETION_PAUSE: 'completion:pause',
  COMPLETION_PAUSED: 'completion:paused',
  COMPLETION_RESUME: 'completion:resume',
  COMPLETION_RESUMED: 'completion:resumed',
  COMPLETION_STOP: 'completion:stop',
  COMPLETION_FINISHED: 'completion:finished',
  ITERATION_STARTED: 'completion:iteration:started',
  ITERATION_COMPLETED: 'completion:iteration:completed',
  GAP_DETECTED: 'completion:gap:detected',
  GAP_RESOLVED: 'completion:gap:resolved',
  PROGRESS_UPDATED: 'completion:progress:updated',
  COMPLETION_ERROR: 'completion:error'
};

export class ProjectCompletionAgent extends EventEmitter {
  constructor(config = {}) {
    super();

    this.name = 'ProjectCompletionAgent';
    this.alias = 'Lucy';
    this.version = '1.0.0';
    this.state = AgentState.IDLE;
    this.logger = createLogger(this.name);

    // Configuration
    this.config = {
      projectRoot: config.projectRoot || process.cwd(),
      stateDir: config.stateDir || '.project-completion',
      targetCompletion: config.targetCompletion || 100,
      maxIterations: config.maxIterations || 50,
      ...config
    };

    // Sub-components
    this.gapDetector = new GapDetector(this.config);
    this.completionTracker = new CompletionTracker(this.config);
    this.loop = new ContinuousLoop(this.config);

    // PlanExecutor for gap resolution (lazy-loaded)
    this._planExecutor = null;

    // Current project being completed
    this.currentProject = null;
    this.gaps = [];

    // Metrics
    this.metrics = {
      iterationsCompleted: 0,
      gapsDetected: 0,
      gapsResolved: 0,
      errorsCount: 0,
      lastActivity: null
    };

    this._setupInternalHandlers();
  }

  /**
   * Initialize the agent with optional eventBus connection
   */
  async initialize(eventBus = null) {
    this.state = AgentState.INITIALIZING;
    this.logger.info(`Initializing ${this.name} (${this.alias})...`);

    try {
      if (eventBus) {
        this.eventBus = eventBus;
        this._subscribeToEvents();
      }

      await this._ensureDirectories();
      await this._loadExistingState();

      // Wire up sub-components
      this.loop.on('iteration:started', (data) => {
        this.emit(CompletionEvents.ITERATION_STARTED, data);
      });

      this.loop.on('iteration:completed', (data) => {
        this.metrics.iterationsCompleted++;
        this.emit(CompletionEvents.ITERATION_COMPLETED, data);
      });

      this.state = AgentState.IDLE;
      this.emit('initialized', { agent: this.name, alias: this.alias, version: this.version });

      return { success: true, agent: this.name };
    } catch (error) {
      this.state = AgentState.ERROR;
      this.logger.error(`Failed to initialize: ${error.message}`);
      this.emit('error', { agent: this.name, error: error.message });
      throw error;
    }
  }

  /**
   * Start autonomous completion for a project
   * @param {object} project - Project to complete (from ProjectManagerAgent)
   * @param {object} options - Completion options
   */
  async startCompletion(project, options = {}) {
    if (this.state !== AgentState.IDLE && this.state !== AgentState.PAUSED) {
      throw new Error(`Cannot start completion in state: ${this.state}`);
    }

    this.logger.info(`Starting completion for project: ${project.name}`);
    this.currentProject = project;
    this.metrics.lastActivity = new Date().toISOString();

    try {
      this.emit(CompletionEvents.COMPLETION_STARTED, { project: project.name });

      if (this.eventBus) {
        this.eventBus.publish(CompletionEvents.COMPLETION_STARTED, { project: project.name });
      }

      // Start the completion loop
      await this._runCompletionLoop(options);

      return { success: true, project: project.name };
    } catch (error) {
      this.state = AgentState.ERROR;
      this.metrics.errorsCount++;
      this.logger.error(`Completion failed: ${error.message}`);
      this.emit(CompletionEvents.COMPLETION_ERROR, { error: error.message });
      throw error;
    }
  }

  /**
   * Pause the completion loop
   */
  async pauseCompletion() {
    if (this.state === AgentState.PAUSED) {
      return { success: true, message: 'Already paused' };
    }

    this.logger.info('Pausing completion...');
    this.state = AgentState.PAUSED;

    await this.loop.pause();
    await this._saveState();

    this.emit(CompletionEvents.COMPLETION_PAUSED, { project: this.currentProject?.name });

    if (this.eventBus) {
      this.eventBus.publish(CompletionEvents.COMPLETION_PAUSED, { project: this.currentProject?.name });
    }

    return { success: true };
  }

  /**
   * Resume the completion loop
   */
  async resumeCompletion() {
    if (this.state !== AgentState.PAUSED) {
      throw new Error(`Cannot resume from state: ${this.state}`);
    }

    this.logger.info('Resuming completion...');
    this.metrics.lastActivity = new Date().toISOString();

    this.emit(CompletionEvents.COMPLETION_RESUMED, { project: this.currentProject?.name });

    if (this.eventBus) {
      this.eventBus.publish(CompletionEvents.COMPLETION_RESUMED, { project: this.currentProject?.name });
    }

    // Resume the loop
    await this.loop.resume();
    await this._runCompletionLoop({});

    return { success: true };
  }

  /**
   * Stop completion entirely
   */
  async stopCompletion() {
    this.logger.info('Stopping completion...');

    await this.loop.stop();
    this.state = AgentState.IDLE;
    this.currentProject = null;

    await this._saveState();

    this.emit(CompletionEvents.COMPLETION_FINISHED, { stopped: true });

    return { success: true };
  }

  /**
   * Get current progress percentage
   * @param {string} projectName - Name of the project
   */
  async getProgress(projectName) {
    const project = projectName || this.currentProject?.name;
    if (!project) {
      return { percentage: 0, gaps: [] };
    }

    const percentage = await this.completionTracker.calculate(project);
    return {
      percentage,
      gaps: this.gaps,
      project
    };
  }

  /**
   * Get list of detected gaps
   */
  getGaps() {
    return this.gaps;
  }

  /**
   * Get current agent status
   */
  getStatus() {
    return {
      name: this.name,
      alias: this.alias,
      version: this.version,
      state: this.state,
      currentProject: this.currentProject?.name || null,
      metrics: this.getMetrics()
    };
  }

  /**
   * Get agent metrics
   */
  getMetrics() {
    return {
      ...this.metrics,
      state: this.state,
      gapsRemaining: this.gaps.length
    };
  }

  /**
   * Shutdown the agent
   */
  async shutdown() {
    this.state = AgentState.SHUTDOWN;
    this.logger.info(`Shutting down ${this.name}...`);

    await this.loop.stop();
    await this._saveState();

    this.emit('shutdown', { agent: this.name });
    this.removeAllListeners();
  }

  // ==================== Private Methods ====================

  /**
   * Get PlanExecutor instance (lazy-load)
   */
  get planExecutor() {
    if (!this._planExecutor) {
      this._planExecutor = getPlanExecutor();
    }
    return this._planExecutor;
  }

  /**
   * Convert a gap to a task for PlanExecutor
   */
  _gapToTask(gap, index) {
    // Map gap types to task categories
    const categoryMap = {
      'backend:endpoint': 'backend',
      'backend:model': 'backend',
      'backend:service': 'backend',
      'frontend:page': 'frontend',
      'frontend:component': 'frontend',
      'test:unit': 'testing',
      'test:integration': 'testing',
      'documentation': 'documentation',
      'configuration': 'setup'
    };

    return {
      id: gap.id,
      name: `Resolve: ${gap.description}`,
      description: gap.description,
      category: categoryMap[gap.type] || 'backend',
      type: 'implementation',
      phase: gap.type.includes('test') ? 'testing' : 'implementation',
      priority: gap.priority,
      complexity: gap.priority <= 2 ? 4 : 2, // Higher priority = more complex
      dependencies: index > 0 ? [] : [],
      location: gap.location,
      gapDetails: gap.details || {}
    };
  }

  async _runCompletionLoop(options) {
    const targetCompletion = options.targetCompletion || this.config.targetCompletion;
    const maxIterations = options.maxIterations || this.config.maxIterations;

    let iteration = 0;

    while (iteration < maxIterations && this.state !== AgentState.PAUSED) {
      iteration++;
      this.logger.info(`Starting iteration ${iteration}...`);

      // Phase 1: Analyze - Detect gaps
      this.state = AgentState.ANALYZING;
      this.gaps = await this.gapDetector.detect(this.currentProject);
      this.metrics.gapsDetected += this.gaps.length;

      if (this.gaps.length > 0) {
        this.emit(CompletionEvents.GAP_DETECTED, { gaps: this.gaps });

        // Publish to EventBus
        if (this.eventBus) {
          this.eventBus.publish(EventTypes.COMPLETION_GAP_DETECTED, {
            project: this.currentProject.name,
            gapCount: this.gaps.length,
            gaps: this.gaps.slice(0, 5) // First 5 for brevity
          });
        }
      }

      // Check completion percentage
      const progress = await this.completionTracker.calculate(this.currentProject.name);

      this.emit(CompletionEvents.PROGRESS_UPDATED, {
        project: this.currentProject.name,
        percentage: progress,
        iteration
      });

      if (this.eventBus) {
        this.eventBus.publish(EventTypes.COMPLETION_PROGRESS_UPDATED, {
          project: this.currentProject.name,
          percentage: progress,
          iteration,
          gapsRemaining: this.gaps.length
        });
      }

      if (progress >= targetCompletion) {
        this.logger.info(`Target completion reached: ${progress}%`);
        this.state = AgentState.COMPLETED;
        this.emit(CompletionEvents.COMPLETION_FINISHED, {
          project: this.currentProject.name,
          percentage: progress
        });
        break;
      }

      if (this.gaps.length === 0) {
        this.logger.info('No gaps detected but target not reached');
        break;
      }

      // Phase 2: Plan - Prioritize gaps and convert to tasks
      this.state = AgentState.PLANNING;
      const prioritizedGaps = await this.gapDetector.prioritize(this.gaps);

      // Take top 3 gaps to work on this iteration
      const gapsToResolve = prioritizedGaps.slice(0, 3);
      const tasks = gapsToResolve.map((gap, i) => this._gapToTask(gap, i));

      // Create a mini-plan for this iteration
      const iterationPlan = {
        id: `completion-${Date.now()}-iter-${iteration}`,
        version: '1.0',
        status: 'pending',
        tasks,
        executionGroups: [{ id: 'group-1', phase: 'implementation', tasks: tasks.map(t => t.id) }],
        checkpoints: [],
        phases: { implementation: tasks },
        metadata: {
          projectName: this.currentProject.name,
          iteration,
          gapCount: gapsToResolve.length
        }
      };

      // Phase 3: Build - Execute the plan via PlanExecutor
      this.state = AgentState.BUILDING;
      this.logger.info(`Executing plan with ${tasks.length} tasks...`);

      try {
        const executionResult = await this.planExecutor.executePlan(iterationPlan, {
          projectInfo: {
            name: this.currentProject.name,
            path: this.currentProject.sourcePath || this.currentProject.path
          }
        });

        this.logger.info(`Execution result: ${executionResult.success ? 'SUCCESS' : 'PARTIAL'}`);

        // Phase 4: Test - Trigger tests via EventBus
        this.state = AgentState.TESTING;
        if (this.eventBus) {
          this.eventBus.publish(EventTypes.TESTS_STARTED, {
            agent: this.name,
            project: this.currentProject.name,
            iteration,
            reason: 'completion_verification'
          });
        }

        // Wait briefly for tests (in real implementation, would await test completion event)
        await new Promise(resolve => setTimeout(resolve, 500));

        // Phase 5: Fix - The autonomous-loop-manager handles this via TESTS_FAILED events
        this.state = AgentState.FIXING;
        // Auto-fix is handled automatically by autonomous-loop-manager subscribing to TESTS_FAILED

        // Phase 6: Verify and update progress
        this.state = AgentState.VERIFYING;

        // Mark resolved gaps
        for (const gap of gapsToResolve) {
          if (executionResult.taskResults[gap.id]?.success) {
            await this.completionTracker.updateProgress(this.currentProject.name, {
              gapResolved: gap.id,
              iteration
            });

            this.metrics.gapsResolved++;
            this.emit(CompletionEvents.GAP_RESOLVED, { gap });

            if (this.eventBus) {
              this.eventBus.publish(EventTypes.COMPLETION_GAP_RESOLVED, { gap });
            }
          }
        }

      } catch (error) {
        this.logger.error(`Execution error: ${error.message}`);
        this.metrics.errorsCount++;

        // Continue to next iteration despite errors
      }

      // Save state after each iteration
      await this._saveState();

      // Delay between iterations
      await new Promise(resolve => setTimeout(resolve, 200));
    }

    if (this.state !== AgentState.PAUSED && this.state !== AgentState.COMPLETED) {
      this.state = AgentState.IDLE;
    }
  }

  _setupInternalHandlers() {
    this.gapDetector.on('error', (error) => {
      this.emit('warning', { source: 'GapDetector', ...error });
    });

    this.completionTracker.on('error', (error) => {
      this.emit('warning', { source: 'CompletionTracker', ...error });
    });

    this.loop.on('error', (error) => {
      this.emit('warning', { source: 'ContinuousLoop', ...error });
    });
  }

  _subscribeToEvents() {
    if (!this.eventBus) return;

    this.eventBus.subscribe(CompletionEvents.COMPLETION_START, this.name, async (data) => {
      this.logger.debug('Received completion:start event');
      if (data.project) {
        await this.startCompletion(data.project, data.options || {});
      }
    });

    this.eventBus.subscribe(CompletionEvents.COMPLETION_PAUSE, this.name, async () => {
      this.logger.debug('Received completion:pause event');
      await this.pauseCompletion();
    });

    this.eventBus.subscribe(CompletionEvents.COMPLETION_RESUME, this.name, async () => {
      this.logger.debug('Received completion:resume event');
      await this.resumeCompletion();
    });

    this.eventBus.subscribe(CompletionEvents.COMPLETION_STOP, this.name, async () => {
      this.logger.debug('Received completion:stop event');
      await this.stopCompletion();
    });
  }

  async _ensureDirectories() {
    const stateDir = path.join(this.config.projectRoot, this.config.stateDir);
    await fs.mkdir(stateDir, { recursive: true });
  }

  async _loadExistingState() {
    try {
      const statePath = path.join(
        this.config.projectRoot,
        this.config.stateDir,
        'completion-state.json'
      );

      const data = await fs.readFile(statePath, 'utf-8');
      const state = JSON.parse(data);

      if (state.currentProject) {
        this.currentProject = state.currentProject;
      }

      if (state.gaps) {
        this.gaps = state.gaps;
      }

      if (state.metrics) {
        this.metrics = { ...this.metrics, ...state.metrics };
      }

      // If was paused, restore that state
      if (state.wasPaused) {
        this.state = AgentState.PAUSED;
      }

    } catch (error) {
      // No existing state - that's okay
    }
  }

  async _saveState() {
    try {
      const stateDir = path.join(this.config.projectRoot, this.config.stateDir);
      await fs.mkdir(stateDir, { recursive: true });

      const statePath = path.join(stateDir, 'completion-state.json');

      const state = {
        currentProject: this.currentProject,
        gaps: this.gaps,
        metrics: this.metrics,
        wasPaused: this.state === AgentState.PAUSED,
        savedAt: new Date().toISOString()
      };

      await fs.writeFile(statePath, JSON.stringify(state, null, 2));
    } catch (error) {
      // Ignore save errors during shutdown
    }
  }
}

// Singleton factory
let instance = null;

/**
 * Get singleton instance of ProjectCompletionAgent
 * @param {object} config - Configuration options
 */
ProjectCompletionAgent.getInstance = function(config) {
  if (!instance) {
    instance = new ProjectCompletionAgent(config);
  }
  return instance;
};

export function getCompletionAgent(config) {
  return ProjectCompletionAgent.getInstance(config);
}

export function resetCompletionAgent() {
  if (instance) {
    instance.shutdown().catch(() => {});
    instance = null;
  }
}

// Re-export sub-components
export { GapDetector };
export { CompletionTracker };
export { ContinuousLoop };

export default ProjectCompletionAgent;
