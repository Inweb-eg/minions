/**
 * Minions - ProjectCompletionAgent (Lucy)
 * ========================================
 * Named after Lucy Wilde - the Self-Improvement Engine.
 * Runs autonomous completion loops until a project reaches 100% completion.
 *
 * Auto-generated by Minions Evolution Pipeline
 */

import EventEmitter from 'events';
import path from 'path';
import fs from 'fs/promises';
import { createLogger } from '../../foundation/common/logger.js';

import GapDetector from './GapDetector.js';
import CompletionTracker from './CompletionTracker.js';
import ContinuousLoop from './ContinuousLoop.js';

// Agent States
export const AgentState = {
  IDLE: 'IDLE',
  INITIALIZING: 'INITIALIZING',
  ANALYZING: 'ANALYZING',
  PLANNING: 'PLANNING',
  BUILDING: 'BUILDING',
  TESTING: 'TESTING',
  FIXING: 'FIXING',
  VERIFYING: 'VERIFYING',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  ERROR: 'ERROR',
  SHUTDOWN: 'SHUTDOWN'
};

// Event Types
export const CompletionEvents = {
  COMPLETION_START: 'completion:start',
  COMPLETION_STARTED: 'completion:started',
  COMPLETION_PAUSE: 'completion:pause',
  COMPLETION_PAUSED: 'completion:paused',
  COMPLETION_RESUME: 'completion:resume',
  COMPLETION_RESUMED: 'completion:resumed',
  COMPLETION_STOP: 'completion:stop',
  COMPLETION_FINISHED: 'completion:finished',
  ITERATION_STARTED: 'completion:iteration:started',
  ITERATION_COMPLETED: 'completion:iteration:completed',
  GAP_DETECTED: 'completion:gap:detected',
  GAP_RESOLVED: 'completion:gap:resolved',
  PROGRESS_UPDATED: 'completion:progress:updated',
  COMPLETION_ERROR: 'completion:error'
};

export class ProjectCompletionAgent extends EventEmitter {
  constructor(config = {}) {
    super();

    this.name = 'ProjectCompletionAgent';
    this.alias = 'Lucy';
    this.version = '1.0.0';
    this.state = AgentState.IDLE;
    this.logger = createLogger(this.name);

    // Configuration
    this.config = {
      projectRoot: config.projectRoot || process.cwd(),
      stateDir: config.stateDir || '.project-completion',
      targetCompletion: config.targetCompletion || 100,
      maxIterations: config.maxIterations || 50,
      ...config
    };

    // Sub-components
    this.gapDetector = new GapDetector(this.config);
    this.completionTracker = new CompletionTracker(this.config);
    this.loop = new ContinuousLoop(this.config);

    // Current project being completed
    this.currentProject = null;
    this.gaps = [];

    // Metrics
    this.metrics = {
      iterationsCompleted: 0,
      gapsDetected: 0,
      gapsResolved: 0,
      errorsCount: 0,
      lastActivity: null
    };

    this._setupInternalHandlers();
  }

  /**
   * Initialize the agent with optional eventBus connection
   */
  async initialize(eventBus = null) {
    this.state = AgentState.INITIALIZING;
    this.logger.info(`Initializing ${this.name} (${this.alias})...`);

    try {
      if (eventBus) {
        this.eventBus = eventBus;
        this._subscribeToEvents();
      }

      await this._ensureDirectories();
      await this._loadExistingState();

      // Wire up sub-components
      this.loop.on('iteration:started', (data) => {
        this.emit(CompletionEvents.ITERATION_STARTED, data);
      });

      this.loop.on('iteration:completed', (data) => {
        this.metrics.iterationsCompleted++;
        this.emit(CompletionEvents.ITERATION_COMPLETED, data);
      });

      this.state = AgentState.IDLE;
      this.emit('initialized', { agent: this.name, alias: this.alias, version: this.version });

      return { success: true, agent: this.name };
    } catch (error) {
      this.state = AgentState.ERROR;
      this.logger.error(`Failed to initialize: ${error.message}`);
      this.emit('error', { agent: this.name, error: error.message });
      throw error;
    }
  }

  /**
   * Start autonomous completion for a project
   * @param {object} project - Project to complete (from ProjectManagerAgent)
   * @param {object} options - Completion options
   */
  async startCompletion(project, options = {}) {
    if (this.state !== AgentState.IDLE && this.state !== AgentState.PAUSED) {
      throw new Error(`Cannot start completion in state: ${this.state}`);
    }

    this.logger.info(`Starting completion for project: ${project.name}`);
    this.currentProject = project;
    this.metrics.lastActivity = new Date().toISOString();

    try {
      this.emit(CompletionEvents.COMPLETION_STARTED, { project: project.name });

      if (this.eventBus) {
        this.eventBus.publish(CompletionEvents.COMPLETION_STARTED, { project: project.name });
      }

      // Start the completion loop
      await this._runCompletionLoop(options);

      return { success: true, project: project.name };
    } catch (error) {
      this.state = AgentState.ERROR;
      this.metrics.errorsCount++;
      this.logger.error(`Completion failed: ${error.message}`);
      this.emit(CompletionEvents.COMPLETION_ERROR, { error: error.message });
      throw error;
    }
  }

  /**
   * Pause the completion loop
   */
  async pauseCompletion() {
    if (this.state === AgentState.PAUSED) {
      return { success: true, message: 'Already paused' };
    }

    this.logger.info('Pausing completion...');
    this.state = AgentState.PAUSED;

    await this.loop.pause();
    await this._saveState();

    this.emit(CompletionEvents.COMPLETION_PAUSED, { project: this.currentProject?.name });

    if (this.eventBus) {
      this.eventBus.publish(CompletionEvents.COMPLETION_PAUSED, { project: this.currentProject?.name });
    }

    return { success: true };
  }

  /**
   * Resume the completion loop
   */
  async resumeCompletion() {
    if (this.state !== AgentState.PAUSED) {
      throw new Error(`Cannot resume from state: ${this.state}`);
    }

    this.logger.info('Resuming completion...');
    this.metrics.lastActivity = new Date().toISOString();

    this.emit(CompletionEvents.COMPLETION_RESUMED, { project: this.currentProject?.name });

    if (this.eventBus) {
      this.eventBus.publish(CompletionEvents.COMPLETION_RESUMED, { project: this.currentProject?.name });
    }

    // Resume the loop
    await this.loop.resume();
    await this._runCompletionLoop({});

    return { success: true };
  }

  /**
   * Stop completion entirely
   */
  async stopCompletion() {
    this.logger.info('Stopping completion...');

    await this.loop.stop();
    this.state = AgentState.IDLE;
    this.currentProject = null;

    await this._saveState();

    this.emit(CompletionEvents.COMPLETION_FINISHED, { stopped: true });

    return { success: true };
  }

  /**
   * Get current progress percentage
   * @param {string} projectName - Name of the project
   */
  async getProgress(projectName) {
    const project = projectName || this.currentProject?.name;
    if (!project) {
      return { percentage: 0, gaps: [] };
    }

    const percentage = await this.completionTracker.calculate(project);
    return {
      percentage,
      gaps: this.gaps,
      project
    };
  }

  /**
   * Get list of detected gaps
   */
  getGaps() {
    return this.gaps;
  }

  /**
   * Get current agent status
   */
  getStatus() {
    return {
      name: this.name,
      alias: this.alias,
      version: this.version,
      state: this.state,
      currentProject: this.currentProject?.name || null,
      metrics: this.getMetrics()
    };
  }

  /**
   * Get agent metrics
   */
  getMetrics() {
    return {
      ...this.metrics,
      state: this.state,
      gapsRemaining: this.gaps.length
    };
  }

  /**
   * Shutdown the agent
   */
  async shutdown() {
    this.state = AgentState.SHUTDOWN;
    this.logger.info(`Shutting down ${this.name}...`);

    await this.loop.stop();
    await this._saveState();

    this.emit('shutdown', { agent: this.name });
    this.removeAllListeners();
  }

  // ==================== Private Methods ====================

  async _runCompletionLoop(options) {
    const targetCompletion = options.targetCompletion || this.config.targetCompletion;
    const maxIterations = options.maxIterations || this.config.maxIterations;

    let iteration = 0;

    while (iteration < maxIterations && this.state !== AgentState.PAUSED) {
      iteration++;
      this.logger.info(`Starting iteration ${iteration}...`);

      // Phase 1: Analyze - Detect gaps
      this.state = AgentState.ANALYZING;
      this.gaps = await this.gapDetector.detect(this.currentProject);
      this.metrics.gapsDetected += this.gaps.length;

      if (this.gaps.length > 0) {
        this.emit(CompletionEvents.GAP_DETECTED, { gaps: this.gaps });
      }

      // Check completion percentage
      const progress = await this.completionTracker.calculate(this.currentProject.name);

      this.emit(CompletionEvents.PROGRESS_UPDATED, {
        project: this.currentProject.name,
        percentage: progress,
        iteration
      });

      if (progress >= targetCompletion) {
        this.logger.info(`Target completion reached: ${progress}%`);
        this.state = AgentState.COMPLETED;
        this.emit(CompletionEvents.COMPLETION_FINISHED, {
          project: this.currentProject.name,
          percentage: progress
        });
        break;
      }

      if (this.gaps.length === 0) {
        this.logger.info('No gaps detected but target not reached');
        break;
      }

      // Phase 2: Plan - Prioritize gaps
      this.state = AgentState.PLANNING;
      const prioritizedGaps = await this.gapDetector.prioritize(this.gaps);

      // Phase 3: Build - Generate code for highest priority gap
      this.state = AgentState.BUILDING;
      const currentGap = prioritizedGaps[0];
      this.logger.info(`Working on gap: ${currentGap.type} - ${currentGap.description}`);

      // TODO: Integrate with code generation (Claude API)
      // For now, emit event for external handling
      this.emit('gap:work', { gap: currentGap, project: this.currentProject });

      // Phase 4: Test
      this.state = AgentState.TESTING;
      // TODO: Run tests

      // Phase 5: Fix (if tests fail)
      this.state = AgentState.FIXING;
      // TODO: Auto-fix failures

      // Phase 6: Verify
      this.state = AgentState.VERIFYING;
      await this.completionTracker.updateProgress(this.currentProject.name, {
        gapResolved: currentGap.id,
        iteration
      });

      this.metrics.gapsResolved++;
      this.emit(CompletionEvents.GAP_RESOLVED, { gap: currentGap });

      // Save state after each iteration
      await this._saveState();

      // Small delay between iterations
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    if (this.state !== AgentState.PAUSED && this.state !== AgentState.COMPLETED) {
      this.state = AgentState.IDLE;
    }
  }

  _setupInternalHandlers() {
    this.gapDetector.on('error', (error) => {
      this.emit('warning', { source: 'GapDetector', ...error });
    });

    this.completionTracker.on('error', (error) => {
      this.emit('warning', { source: 'CompletionTracker', ...error });
    });

    this.loop.on('error', (error) => {
      this.emit('warning', { source: 'ContinuousLoop', ...error });
    });
  }

  _subscribeToEvents() {
    if (!this.eventBus) return;

    this.eventBus.subscribe(CompletionEvents.COMPLETION_START, this.name, async (data) => {
      this.logger.debug('Received completion:start event');
      if (data.project) {
        await this.startCompletion(data.project, data.options || {});
      }
    });

    this.eventBus.subscribe(CompletionEvents.COMPLETION_PAUSE, this.name, async () => {
      this.logger.debug('Received completion:pause event');
      await this.pauseCompletion();
    });

    this.eventBus.subscribe(CompletionEvents.COMPLETION_RESUME, this.name, async () => {
      this.logger.debug('Received completion:resume event');
      await this.resumeCompletion();
    });

    this.eventBus.subscribe(CompletionEvents.COMPLETION_STOP, this.name, async () => {
      this.logger.debug('Received completion:stop event');
      await this.stopCompletion();
    });
  }

  async _ensureDirectories() {
    const stateDir = path.join(this.config.projectRoot, this.config.stateDir);
    await fs.mkdir(stateDir, { recursive: true });
  }

  async _loadExistingState() {
    try {
      const statePath = path.join(
        this.config.projectRoot,
        this.config.stateDir,
        'completion-state.json'
      );

      const data = await fs.readFile(statePath, 'utf-8');
      const state = JSON.parse(data);

      if (state.currentProject) {
        this.currentProject = state.currentProject;
      }

      if (state.gaps) {
        this.gaps = state.gaps;
      }

      if (state.metrics) {
        this.metrics = { ...this.metrics, ...state.metrics };
      }

      // If was paused, restore that state
      if (state.wasPaused) {
        this.state = AgentState.PAUSED;
      }

    } catch (error) {
      // No existing state - that's okay
    }
  }

  async _saveState() {
    try {
      const stateDir = path.join(this.config.projectRoot, this.config.stateDir);
      await fs.mkdir(stateDir, { recursive: true });

      const statePath = path.join(stateDir, 'completion-state.json');

      const state = {
        currentProject: this.currentProject,
        gaps: this.gaps,
        metrics: this.metrics,
        wasPaused: this.state === AgentState.PAUSED,
        savedAt: new Date().toISOString()
      };

      await fs.writeFile(statePath, JSON.stringify(state, null, 2));
    } catch (error) {
      // Ignore save errors during shutdown
    }
  }
}

// Singleton factory
let instance = null;

/**
 * Get singleton instance of ProjectCompletionAgent
 * @param {object} config - Configuration options
 */
ProjectCompletionAgent.getInstance = function(config) {
  if (!instance) {
    instance = new ProjectCompletionAgent(config);
  }
  return instance;
};

export function getCompletionAgent(config) {
  return ProjectCompletionAgent.getInstance(config);
}

export function resetCompletionAgent() {
  if (instance) {
    instance.shutdown().catch(() => {});
    instance = null;
  }
}

// Re-export sub-components
export { GapDetector };
export { CompletionTracker };
export { ContinuousLoop };

export default ProjectCompletionAgent;
