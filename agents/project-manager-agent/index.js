/**
 * Minions - ProjectManagerAgent (Silas)
 * ======================================
 * Named after Silas Ramsbottom - the Resource Allocator.
 * Manages connections between Minions and external projects.
 *
 * Auto-generated by Minions Evolution Pipeline
 */

import EventEmitter from 'events';
import path from 'path';
import fs from 'fs/promises';
import { createLogger } from '../../foundation/common/logger.js';

import ProjectRegistry from './ProjectRegistry.js';
import ProjectScanner from './ProjectScanner.js';
import ProjectInitializer from './ProjectInitializer.js';

// Agent States
export const AgentState = {
  IDLE: 'IDLE',
  INITIALIZING: 'INITIALIZING',
  CONNECTING: 'CONNECTING',
  SCANNING: 'SCANNING',
  SYNCING: 'SYNCING',
  ERROR: 'ERROR',
  SHUTDOWN: 'SHUTDOWN'
};

// Event Types
export const ProjectManagerEvents = {
  PROJECT_CONNECT: 'project:connect',
  PROJECT_CONNECTED: 'project:connected',
  PROJECT_DISCONNECT: 'project:disconnect',
  PROJECT_DISCONNECTED: 'project:disconnected',
  PROJECT_SCAN: 'project:scan',
  PROJECT_SCANNED: 'project:scanned',
  PROJECT_SYNC: 'project:sync',
  PROJECT_SYNCED: 'project:synced',
  PROJECT_ERROR: 'project:error'
};

export class ProjectManagerAgent extends EventEmitter {
  constructor(config = {}) {
    super();

    this.name = 'ProjectManagerAgent';
    this.alias = 'Silas';
    this.version = '1.0.0';
    this.state = AgentState.IDLE;
    this.logger = createLogger(this.name);

    // Configuration
    this.config = {
      projectRoot: config.projectRoot || process.cwd(),
      stateDir: config.stateDir || '.project-manager',
      projectsDir: config.projectsDir || 'projects',
      ...config
    };

    // Sub-components
    this.registry = new ProjectRegistry(this.config);
    this.scanner = new ProjectScanner(this.config);
    this.initializer = new ProjectInitializer(this.config);

    // Connected projects cache
    this.projects = new Map();

    // Metrics
    this.metrics = {
      projectsConnected: 0,
      scansCompleted: 0,
      errorsCount: 0,
      lastActivity: null
    };

    this._setupInternalHandlers();
  }

  /**
   * Initialize the agent with optional eventBus connection
   */
  async initialize(eventBus = null) {
    this.state = AgentState.INITIALIZING;
    this.logger.info(`Initializing ${this.name} (${this.alias})...`);

    try {
      if (eventBus) {
        this.eventBus = eventBus;
        this._subscribeToEvents();
      }

      await this._ensureDirectories();
      await this._loadExistingState();

      // Initialize sub-components
      await this.registry.load();

      this.state = AgentState.IDLE;
      this.emit('initialized', { agent: this.name, alias: this.alias, version: this.version });

      return { success: true, agent: this.name };
    } catch (error) {
      this.state = AgentState.ERROR;
      this.logger.error(`Failed to initialize: ${error.message}`);
      this.emit('error', { agent: this.name, error: error.message });
      throw error;
    }
  }

  /**
   * Connect to a new external project
   * @param {string} projectPath - Absolute path to the project
   * @param {object} options - Connection options
   */
  async connect(projectPath, options = {}) {
    this.state = AgentState.CONNECTING;
    this.logger.info(`Connecting to project at: ${projectPath}`);
    this.metrics.lastActivity = new Date().toISOString();

    try {
      // Validate project path exists
      const stats = await fs.stat(projectPath);
      if (!stats.isDirectory()) {
        throw new Error(`Path is not a directory: ${projectPath}`);
      }

      // Extract project name from path
      const projectName = options.name || path.basename(projectPath);

      // Check if already connected
      if (this.registry.getProject(projectName)) {
        throw new Error(`Project already connected: ${projectName}`);
      }

      // Scan the project
      this.state = AgentState.SCANNING;
      const scanResult = await this.scanner.scan(projectPath);

      // Initialize project workspace in projects folder
      const workspace = await this.initializer.initialize(projectName, {
        sourcePath: projectPath,
        scanResult
      });

      // Create project entry
      const project = {
        name: projectName,
        sourcePath: projectPath,
        workspacePath: workspace.path,
        framework: scanResult.framework,
        language: scanResult.language,
        components: scanResult.components,
        connectedAt: new Date().toISOString(),
        lastSyncedAt: new Date().toISOString(),
        status: 'connected'
      };

      // Add to registry
      await this.registry.addProject(project);
      this.projects.set(projectName, project);
      this.metrics.projectsConnected++;

      this.state = AgentState.IDLE;
      this.emit(ProjectManagerEvents.PROJECT_CONNECTED, project);

      if (this.eventBus) {
        this.eventBus.publish(ProjectManagerEvents.PROJECT_CONNECTED, project);
      }

      await this._saveState();

      return { success: true, project };
    } catch (error) {
      this.state = AgentState.ERROR;
      this.metrics.errorsCount++;
      this.logger.error(`Failed to connect project: ${error.message}`);
      this.emit(ProjectManagerEvents.PROJECT_ERROR, { error: error.message });
      throw error;
    }
  }

  /**
   * Disconnect from a project
   * @param {string} projectName - Name of the project to disconnect
   */
  async disconnect(projectName) {
    this.logger.info(`Disconnecting project: ${projectName}`);
    this.metrics.lastActivity = new Date().toISOString();

    try {
      const project = this.registry.getProject(projectName);
      if (!project) {
        throw new Error(`Project not found: ${projectName}`);
      }

      // Cleanup workspace
      await this.initializer.cleanup(projectName);

      // Remove from registry
      await this.registry.removeProject(projectName);
      this.projects.delete(projectName);

      this.emit(ProjectManagerEvents.PROJECT_DISCONNECTED, { name: projectName });

      if (this.eventBus) {
        this.eventBus.publish(ProjectManagerEvents.PROJECT_DISCONNECTED, { name: projectName });
      }

      await this._saveState();

      return { success: true, projectName };
    } catch (error) {
      this.metrics.errorsCount++;
      this.logger.error(`Failed to disconnect project: ${error.message}`);
      throw error;
    }
  }

  /**
   * Scan a project structure and detect frameworks
   * @param {string} projectName - Name of connected project
   */
  async scan(projectName) {
    this.state = AgentState.SCANNING;
    this.logger.info(`Scanning project: ${projectName}`);
    this.metrics.lastActivity = new Date().toISOString();

    try {
      const project = this.registry.getProject(projectName);
      if (!project) {
        throw new Error(`Project not found: ${projectName}`);
      }

      const scanResult = await this.scanner.scan(project.sourcePath);

      // Update project info
      project.framework = scanResult.framework;
      project.language = scanResult.language;
      project.components = scanResult.components;
      project.lastScannedAt = new Date().toISOString();

      await this.registry.updateProject(projectName, project);
      this.projects.set(projectName, project);
      this.metrics.scansCompleted++;

      this.state = AgentState.IDLE;
      this.emit(ProjectManagerEvents.PROJECT_SCANNED, { name: projectName, result: scanResult });

      await this._saveState();

      return { success: true, project, scanResult };
    } catch (error) {
      this.state = AgentState.ERROR;
      this.metrics.errorsCount++;
      this.logger.error(`Failed to scan project: ${error.message}`);
      throw error;
    }
  }

  /**
   * List all connected projects
   */
  list() {
    return this.registry.getAllProjects();
  }

  /**
   * Get current agent status
   */
  getStatus() {
    return {
      name: this.name,
      alias: this.alias,
      version: this.version,
      state: this.state,
      metrics: this.getMetrics()
    };
  }

  /**
   * Get a project by name
   * @param {string} projectName - Name of the project
   */
  getProject(projectName) {
    return this.registry.getProject(projectName);
  }

  /**
   * Sync project state
   * @param {string} projectName - Name of the project
   */
  async syncProject(projectName) {
    this.state = AgentState.SYNCING;
    this.logger.info(`Syncing project: ${projectName}`);
    this.metrics.lastActivity = new Date().toISOString();

    try {
      const project = this.registry.getProject(projectName);
      if (!project) {
        throw new Error(`Project not found: ${projectName}`);
      }

      // Re-scan for changes
      const scanResult = await this.scanner.scan(project.sourcePath);

      project.framework = scanResult.framework;
      project.language = scanResult.language;
      project.components = scanResult.components;
      project.lastSyncedAt = new Date().toISOString();

      await this.registry.updateProject(projectName, project);
      this.projects.set(projectName, project);

      this.state = AgentState.IDLE;
      this.emit(ProjectManagerEvents.PROJECT_SYNCED, { name: projectName });

      if (this.eventBus) {
        this.eventBus.publish(ProjectManagerEvents.PROJECT_SYNCED, { name: projectName });
      }

      await this._saveState();

      return { success: true, project };
    } catch (error) {
      this.state = AgentState.ERROR;
      this.metrics.errorsCount++;
      this.logger.error(`Failed to sync project: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get agent metrics
   */
  getMetrics() {
    return {
      ...this.metrics,
      state: this.state,
      projectCount: this.projects.size
    };
  }

  /**
   * Shutdown the agent
   */
  async shutdown() {
    this.state = AgentState.SHUTDOWN;
    this.logger.info(`Shutting down ${this.name}...`);

    await this._saveState();

    this.emit('shutdown', { agent: this.name });
    this.removeAllListeners();
  }

  // ==================== Private Methods ====================

  _setupInternalHandlers() {
    this.registry.on('error', (error) => {
      this.emit('warning', { source: 'ProjectRegistry', ...error });
    });
  }

  _subscribeToEvents() {
    if (!this.eventBus) return;

    this.eventBus.subscribe(ProjectManagerEvents.PROJECT_CONNECT, this.name, async (data) => {
      this.logger.debug('Received project:connect event');
      if (data.path) {
        await this.connect(data.path, data.options || {});
      }
    });

    this.eventBus.subscribe(ProjectManagerEvents.PROJECT_DISCONNECT, this.name, async (data) => {
      this.logger.debug('Received project:disconnect event');
      if (data.name) {
        await this.disconnect(data.name);
      }
    });

    this.eventBus.subscribe(ProjectManagerEvents.PROJECT_SCAN, this.name, async (data) => {
      this.logger.debug('Received project:scan event');
      if (data.name) {
        await this.scan(data.name);
      }
    });

    this.eventBus.subscribe(ProjectManagerEvents.PROJECT_SYNC, this.name, async (data) => {
      this.logger.debug('Received project:sync event');
      if (data.name) {
        await this.syncProject(data.name);
      }
    });
  }

  async _ensureDirectories() {
    const stateDir = path.join(this.config.projectRoot, this.config.stateDir);
    const projectsDir = path.join(this.config.projectRoot, this.config.projectsDir);
    await fs.mkdir(stateDir, { recursive: true });
    await fs.mkdir(projectsDir, { recursive: true });
  }

  async _loadExistingState() {
    try {
      const statePath = path.join(
        this.config.projectRoot,
        this.config.stateDir,
        'project-manager-state.json'
      );

      const data = await fs.readFile(statePath, 'utf-8');
      const state = JSON.parse(data);

      if (state.metrics) {
        this.metrics = { ...this.metrics, ...state.metrics };
      }

      // Reload projects from registry
      const projects = this.registry.getAllProjects();
      projects.forEach(p => this.projects.set(p.name, p));

    } catch (error) {
      // No existing state - that's okay
    }
  }

  async _saveState() {
    try {
      const stateDir = path.join(this.config.projectRoot, this.config.stateDir);
      await fs.mkdir(stateDir, { recursive: true });

      const statePath = path.join(stateDir, 'project-manager-state.json');

      const state = {
        metrics: this.metrics,
        savedAt: new Date().toISOString()
      };

      await fs.writeFile(statePath, JSON.stringify(state, null, 2));
    } catch (error) {
      // Ignore save errors during shutdown
    }
  }
}

// Singleton factory
let instance = null;

export function getProjectManager(config) {
  if (!instance) {
    instance = new ProjectManagerAgent(config);
  }
  return instance;
}

export function resetProjectManager() {
  if (instance) {
    instance.shutdown().catch(() => {});
    instance = null;
  }
}

// Re-export sub-components
export { ProjectRegistry };
export { ProjectScanner };
export { ProjectInitializer };

export default ProjectManagerAgent;
