/**
 * ProjectRegistry
 * ---------------
 * Manages the master registry of all connected projects with persistence.
 *
 * Auto-generated by Minions Evolution Pipeline
 */

import EventEmitter from 'events';
import fs from 'fs/promises';
import path from 'path';

export class ProjectRegistry extends EventEmitter {
  constructor(config = {}) {
    super();
    this.config = config;
    this.projects = new Map();
    this.registryPath = path.join(
      config.projectRoot || process.cwd(),
      config.projectsDir || 'projects',
      '.registry.json'
    );
  }

  /**
   * Load registry from disk
   */
  async load() {
    try {
      const data = await fs.readFile(this.registryPath, 'utf-8');
      const registry = JSON.parse(data);

      if (registry.projects && Array.isArray(registry.projects)) {
        this.projects.clear();
        registry.projects.forEach(project => {
          this.projects.set(project.name, project);
        });
      }

      return { success: true, projectCount: this.projects.size };
    } catch (error) {
      if (error.code === 'ENOENT') {
        // No existing registry - that's okay
        return { success: true, projectCount: 0 };
      }
      this.emit('error', { method: 'load', error: error.message });
      throw error;
    }
  }

  /**
   * Save registry to disk
   */
  async save() {
    try {
      const registry = {
        version: '1.0.0',
        updatedAt: new Date().toISOString(),
        projects: Array.from(this.projects.values())
      };

      await fs.writeFile(this.registryPath, JSON.stringify(registry, null, 2));
      return { success: true };
    } catch (error) {
      this.emit('error', { method: 'save', error: error.message });
      throw error;
    }
  }

  /**
   * Add a project to the registry
   * @param {object} project - Project data
   */
  async addProject(project) {
    if (!project || !project.name) {
      throw new Error('Project must have a name');
    }

    if (this.projects.has(project.name)) {
      throw new Error(`Project already exists: ${project.name}`);
    }

    this.projects.set(project.name, {
      ...project,
      registeredAt: new Date().toISOString()
    });

    await this.save();
    return { success: true, project };
  }

  /**
   * Remove a project from the registry
   * @param {string} name - Project name
   */
  async removeProject(name) {
    if (!this.projects.has(name)) {
      throw new Error(`Project not found: ${name}`);
    }

    this.projects.delete(name);
    await this.save();
    return { success: true, name };
  }

  /**
   * Get a project by name
   * @param {string} name - Project name
   */
  getProject(name) {
    return this.projects.get(name) || null;
  }

  /**
   * Get all projects
   */
  getAllProjects() {
    return Array.from(this.projects.values());
  }

  /**
   * Update a project
   * @param {string} name - Project name
   * @param {object} updates - Updates to apply
   */
  async updateProject(name, updates) {
    const existing = this.projects.get(name);
    if (!existing) {
      throw new Error(`Project not found: ${name}`);
    }

    const updated = {
      ...existing,
      ...updates,
      updatedAt: new Date().toISOString()
    };

    this.projects.set(name, updated);
    await this.save();
    return { success: true, project: updated };
  }

  /**
   * Check if a project exists
   * @param {string} name - Project name
   */
  hasProject(name) {
    return this.projects.has(name);
  }

  /**
   * Get project count
   */
  getCount() {
    return this.projects.size;
  }

  async shutdown() {
    await this.save();
    this.projects.clear();
    this.removeAllListeners();
  }
}

export default ProjectRegistry;
