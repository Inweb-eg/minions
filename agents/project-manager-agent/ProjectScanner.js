/**
 * ProjectScanner
 * --------------
 * Scans external project structure and detects frameworks, languages, and architecture.
 *
 * Auto-generated by Minions Evolution Pipeline
 */

import EventEmitter from 'events';
import fs from 'fs/promises';
import path from 'path';

export class ProjectScanner extends EventEmitter {
  constructor(config = {}) {
    super();
    this.config = config;
  }

  /**
   * Full project scan
   * @param {string} projectPath - Path to project root
   */
  async scan(projectPath) {
    try {
      const result = {
        path: projectPath,
        framework: null,
        language: null,
        components: [],
        dependencies: {},
        scannedAt: new Date().toISOString()
      };

      // Detect framework and language
      result.framework = await this.detectFramework(projectPath);
      result.language = await this.detectLanguage(projectPath);
      result.components = await this.detectComponents(projectPath);

      return result;
    } catch (error) {
      this.emit('error', { method: 'scan', error: error.message });
      throw error;
    }
  }

  /**
   * Detect framework used by the project
   * @param {string} projectPath - Path to project root
   */
  async detectFramework(projectPath) {
    const frameworks = [];

    // Check for package.json (Node.js projects)
    try {
      const packagePath = path.join(projectPath, 'package.json');
      const packageData = await fs.readFile(packagePath, 'utf-8');
      const pkg = JSON.parse(packageData);
      const deps = { ...pkg.dependencies, ...pkg.devDependencies };

      if (deps.next) frameworks.push('Next.js');
      if (deps.react && !deps.next) frameworks.push('React');
      if (deps.vue) frameworks.push('Vue');
      if (deps.express) frameworks.push('Express');
      if (deps.fastify) frameworks.push('Fastify');
      if (deps.nest) frameworks.push('NestJS');
      if (deps['@angular/core']) frameworks.push('Angular');
      if (deps.svelte) frameworks.push('Svelte');
    } catch (e) {
      // No package.json
    }

    // Check for pubspec.yaml (Flutter/Dart projects)
    try {
      const pubspecPath = path.join(projectPath, 'pubspec.yaml');
      await fs.access(pubspecPath);
      frameworks.push('Flutter');
    } catch (e) {
      // No pubspec.yaml
    }

    // Check for requirements.txt or pyproject.toml (Python projects)
    try {
      const requirementsPath = path.join(projectPath, 'requirements.txt');
      const data = await fs.readFile(requirementsPath, 'utf-8');
      if (data.includes('django')) frameworks.push('Django');
      if (data.includes('flask')) frameworks.push('Flask');
      if (data.includes('fastapi')) frameworks.push('FastAPI');
    } catch (e) {
      // No requirements.txt
    }

    // Check for go.mod (Go projects)
    try {
      const goModPath = path.join(projectPath, 'go.mod');
      await fs.access(goModPath);
      frameworks.push('Go');
    } catch (e) {
      // No go.mod
    }

    return frameworks.length > 0 ? frameworks : ['Unknown'];
  }

  /**
   * Detect programming language
   * @param {string} projectPath - Path to project root
   */
  async detectLanguage(projectPath) {
    const languages = [];

    // Check for language-specific files
    const checks = [
      { file: 'package.json', lang: 'JavaScript/TypeScript' },
      { file: 'tsconfig.json', lang: 'TypeScript' },
      { file: 'pubspec.yaml', lang: 'Dart' },
      { file: 'requirements.txt', lang: 'Python' },
      { file: 'pyproject.toml', lang: 'Python' },
      { file: 'go.mod', lang: 'Go' },
      { file: 'Cargo.toml', lang: 'Rust' },
      { file: 'pom.xml', lang: 'Java' },
      { file: 'build.gradle', lang: 'Java/Kotlin' },
      { file: 'composer.json', lang: 'PHP' },
      { file: 'Gemfile', lang: 'Ruby' }
    ];

    for (const check of checks) {
      try {
        await fs.access(path.join(projectPath, check.file));
        if (!languages.includes(check.lang)) {
          languages.push(check.lang);
        }
      } catch (e) {
        // File doesn't exist
      }
    }

    return languages.length > 0 ? languages : ['Unknown'];
  }

  /**
   * Detect project components (backend, frontend, mobile, etc.)
   * @param {string} projectPath - Path to project root
   */
  async detectComponents(projectPath) {
    const components = [];

    // Check common directory patterns
    const patterns = [
      { dir: 'src', type: 'source' },
      { dir: 'apps', type: 'monorepo-apps' },
      { dir: 'packages', type: 'monorepo-packages' },
      { dir: 'backend', type: 'backend' },
      { dir: 'frontend', type: 'frontend' },
      { dir: 'api', type: 'api' },
      { dir: 'web', type: 'web' },
      { dir: 'mobile', type: 'mobile' },
      { dir: 'admin', type: 'admin' },
      { dir: 'client', type: 'client' },
      { dir: 'server', type: 'server' },
      { dir: 'lib', type: 'library' },
      { dir: 'test', type: 'tests' },
      { dir: 'tests', type: 'tests' },
      { dir: '__tests__', type: 'tests' },
      { dir: 'docs', type: 'documentation' }
    ];

    for (const pattern of patterns) {
      try {
        const dirPath = path.join(projectPath, pattern.dir);
        const stats = await fs.stat(dirPath);
        if (stats.isDirectory()) {
          components.push({
            name: pattern.dir,
            type: pattern.type,
            path: dirPath
          });
        }
      } catch (e) {
        // Directory doesn't exist
      }
    }

    // Check for monorepo apps
    try {
      const appsDir = path.join(projectPath, 'apps');
      const apps = await fs.readdir(appsDir);
      for (const app of apps) {
        const appPath = path.join(appsDir, app);
        const stats = await fs.stat(appPath);
        if (stats.isDirectory()) {
          components.push({
            name: app,
            type: 'app',
            path: appPath,
            parent: 'apps'
          });
        }
      }
    } catch (e) {
      // No apps directory
    }

    return components;
  }

  /**
   * Generate project configuration from scan results
   * @param {object} scanResult - Result from scan()
   */
  generateConfig(scanResult) {
    return {
      name: path.basename(scanResult.path),
      version: '1.0.0',
      framework: scanResult.framework,
      language: scanResult.language,
      components: scanResult.components.map(c => ({
        name: c.name,
        type: c.type
      })),
      createdAt: new Date().toISOString()
    };
  }

  async shutdown() {
    this.removeAllListeners();
  }
}

export default ProjectScanner;
