/**
 * ProjectInitializer
 * ------------------
 * Creates and sets up project workspace folders in the projects directory.
 *
 * Auto-generated by Minions Evolution Pipeline
 */

import EventEmitter from 'events';
import fs from 'fs/promises';
import path from 'path';

export class ProjectInitializer extends EventEmitter {
  constructor(config = {}) {
    super();
    this.config = config;
    this.projectsDir = path.join(
      config.projectRoot || process.cwd(),
      config.projectsDir || 'projects'
    );
  }

  /**
   * Initialize a project workspace
   * @param {string} projectName - Name of the project
   * @param {object} options - Initialization options
   */
  async initialize(projectName, options = {}) {
    try {
      const workspacePath = path.join(this.projectsDir, projectName);

      // Create workspace folder structure
      await this.createFolders(projectName);

      // Create project.json configuration
      await this.createProjectJson(projectName, options);

      // Create state.json for tracking
      await this.createStateJson(projectName);

      return {
        success: true,
        name: projectName,
        path: workspacePath
      };
    } catch (error) {
      this.emit('error', { method: 'initialize', error: error.message });
      throw error;
    }
  }

  /**
   * Create folder structure for a project
   * @param {string} projectName - Name of the project
   */
  async createFolders(projectName) {
    const workspacePath = path.join(this.projectsDir, projectName);

    // Create main workspace directory
    await fs.mkdir(workspacePath, { recursive: true });

    // Create standard subdirectories
    const subdirs = [
      '.minions',           // Minions state and config
      '.minions/plans',     // Generated plans
      '.minions/gaps',      // Detected gaps
      '.minions/history',   // Completion history
      'generated'           // Generated code staging
    ];

    for (const subdir of subdirs) {
      await fs.mkdir(path.join(workspacePath, subdir), { recursive: true });
    }

    return { success: true, path: workspacePath };
  }

  /**
   * Create project.json configuration file
   * @param {string} projectName - Name of the project
   * @param {object} options - Configuration options
   */
  async createProjectJson(projectName, options = {}) {
    const workspacePath = path.join(this.projectsDir, projectName);
    const configPath = path.join(workspacePath, '.minions', 'project.json');

    const config = {
      name: projectName,
      version: '1.0.0',
      sourcePath: options.sourcePath || null,
      framework: options.scanResult?.framework || [],
      language: options.scanResult?.language || [],
      components: options.scanResult?.components || [],
      settings: {
        autoCommit: true,
        maxIterations: 50,
        targetCompletion: 100
      },
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    await fs.writeFile(configPath, JSON.stringify(config, null, 2));
    return { success: true, path: configPath };
  }

  /**
   * Create state.json for tracking progress
   * @param {string} projectName - Name of the project
   */
  async createStateJson(projectName) {
    const workspacePath = path.join(this.projectsDir, projectName);
    const statePath = path.join(workspacePath, '.minions', 'state.json');

    const state = {
      version: '1.0.0',
      status: 'initialized',
      completion: {
        percentage: 0,
        lastCalculated: null
      },
      gaps: {
        total: 0,
        resolved: 0,
        pending: 0
      },
      iterations: {
        count: 0,
        lastRun: null
      },
      history: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    await fs.writeFile(statePath, JSON.stringify(state, null, 2));
    return { success: true, path: statePath };
  }

  /**
   * Remove project workspace (cleanup)
   * @param {string} projectName - Name of the project
   */
  async cleanup(projectName) {
    try {
      const workspacePath = path.join(this.projectsDir, projectName);

      // Verify it's a valid project workspace
      const configPath = path.join(workspacePath, '.minions', 'project.json');
      await fs.access(configPath);

      // Remove the entire workspace
      await fs.rm(workspacePath, { recursive: true, force: true });

      return { success: true, name: projectName };
    } catch (error) {
      if (error.code === 'ENOENT') {
        // Workspace doesn't exist - that's okay
        return { success: true, name: projectName, note: 'Workspace did not exist' };
      }
      this.emit('error', { method: 'cleanup', error: error.message });
      throw error;
    }
  }

  /**
   * Check if a project workspace exists
   * @param {string} projectName - Name of the project
   */
  async exists(projectName) {
    try {
      const workspacePath = path.join(this.projectsDir, projectName);
      const configPath = path.join(workspacePath, '.minions', 'project.json');
      await fs.access(configPath);
      return true;
    } catch (e) {
      return false;
    }
  }

  /**
   * Get project workspace path
   * @param {string} projectName - Name of the project
   */
  getWorkspacePath(projectName) {
    return path.join(this.projectsDir, projectName);
  }

  async shutdown() {
    this.removeAllListeners();
  }
}

export default ProjectInitializer;
