/**
 * ProjectInitializer
 * ------------------
 * Creates and sets up project workspace folders in the projects directory.
 *
 * Auto-generated by Minions Evolution Pipeline
 */

import EventEmitter from 'events';
import fs from 'fs/promises';
import path from 'path';

export class ProjectInitializer extends EventEmitter {
  constructor(config = {}) {
    super();
    this.config = config;
    this.projectsDir = path.join(
      config.projectRoot || process.cwd(),
      config.projectsDir || 'projects'
    );
  }

  /**
   * Initialize a project workspace
   * @param {string} projectName - Name of the project
   * @param {object} options - Initialization options
   */
  async initialize(projectName, options = {}) {
    try {
      const workspacePath = path.join(this.projectsDir, projectName);

      // Create workspace folder structure
      await this.createFolders(projectName);

      // Create core Silas files
      await this.createProjectJson(projectName, options);
      await this.createStateJson(projectName);
      await this.createReadme(projectName, options);

      // Create Nefario files
      await this.createScopeJson(projectName, options);
      await this.createRequirementsJson(projectName);
      await this.createAssumptionsJson(projectName);

      // Create Tom files
      await this.createRisksJson(projectName);
      await this.createSecurityFiles(projectName);
      await this.createOpsFiles(projectName);

      // Create Lucy files
      await this.createGapsJson(projectName);
      await this.createQualityFiles(projectName);

      this.emit('project:structure:created', { projectName, workspacePath });

      return {
        success: true,
        name: projectName,
        path: workspacePath
      };
    } catch (error) {
      this.emit('error', { method: 'initialize', error: error.message });
      throw error;
    }
  }

  /**
   * Create folder structure for a project
   * @param {string} projectName - Name of the project
   */
  async createFolders(projectName) {
    const workspacePath = path.join(this.projectsDir, projectName);

    // Create main workspace directory
    await fs.mkdir(workspacePath, { recursive: true });

    // Create standard subdirectories
    const subdirs = [
      '.minions',              // Minions state and config
      '.minions/plans',        // Generated plans
      '.minions/gaps',         // Detected gaps
      '.minions/history',      // Completion history
      'generated',             // Generated code staging
      'security',              // Tom's security files
      'ops',                   // Tom's ops files
      'ops/runbooks',          // Operational runbooks
      'quality',               // Lucy's quality metrics
      'architecture',          // Nefario's architecture files
      'architecture/decisions' // Architecture Decision Records
    ];

    for (const subdir of subdirs) {
      await fs.mkdir(path.join(workspacePath, subdir), { recursive: true });
    }

    return { success: true, path: workspacePath };
  }

  /**
   * Create project.json configuration file
   * @param {string} projectName - Name of the project
   * @param {object} options - Configuration options
   */
  async createProjectJson(projectName, options = {}) {
    const workspacePath = path.join(this.projectsDir, projectName);
    const configPath = path.join(workspacePath, '.minions', 'project.json');

    const config = {
      name: projectName,
      version: '1.0.0',
      sourcePath: options.sourcePath || null,
      framework: options.scanResult?.framework || [],
      language: options.scanResult?.language || [],
      components: options.scanResult?.components || [],
      settings: {
        autoCommit: true,
        maxIterations: 50,
        targetCompletion: 100
      },
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    await fs.writeFile(configPath, JSON.stringify(config, null, 2));
    return { success: true, path: configPath };
  }

  /**
   * Create state.json for tracking progress
   * @param {string} projectName - Name of the project
   */
  async createStateJson(projectName) {
    const workspacePath = path.join(this.projectsDir, projectName);
    const statePath = path.join(workspacePath, '.minions', 'state.json');

    const state = {
      version: '1.0.0',
      status: 'initialized',
      completion: {
        percentage: 0,
        lastCalculated: null
      },
      gaps: {
        total: 0,
        resolved: 0,
        pending: 0
      },
      iterations: {
        count: 0,
        lastRun: null
      },
      history: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    await fs.writeFile(statePath, JSON.stringify(state, null, 2));
    return { success: true, path: statePath };
  }

  /**
   * Create README.md for the project
   * @param {string} projectName - Name of the project
   * @param {object} options - Configuration options
   */
  async createReadme(projectName, options = {}) {
    const workspacePath = path.join(this.projectsDir, projectName);
    const readmePath = path.join(workspacePath, 'README.md');

    const content = `# ${projectName}

> Auto-generated by Minions Framework

## Overview

${options.description || 'Project description goes here.'}

## Structure

- \`project.json\` - Project configuration (Silas)
- \`state.json\` - Project state tracking (Silas)
- \`scope.json\` - Project scope and boundaries (Nefario)
- \`requirements.json\` - Functional and non-functional requirements (Nefario)
- \`assumptions.json\` - Project assumptions (Shared)
- \`risks.json\` - Risk register (Tom)
- \`gaps.json\` - Gap analysis (Lucy)
- \`security/\` - Security files (Tom)
- \`ops/\` - Operations files (Tom)
- \`quality/\` - Quality metrics (Lucy)
- \`architecture/\` - Architecture documentation (Nefario)

## Agents

- **Silas** (ProjectManager): Manages project configuration and state
- **Nefario** (Planner): Handles scope, requirements, and architecture
- **Tom** (SecurityRisk): Manages security, risks, and operations
- **Lucy** (ProjectCompletion): Tracks gaps and quality metrics
`;

    await fs.writeFile(readmePath, content);
    return { success: true, path: readmePath };
  }

  /**
   * Create scope.json for Nefario
   * @param {string} projectName - Name of the project
   * @param {object} options - Configuration options
   */
  async createScopeJson(projectName, options = {}) {
    const workspacePath = path.join(this.projectsDir, projectName);
    const scopePath = path.join(workspacePath, 'scope.json');

    const scope = {
      version: '1.0.0',
      projectName,
      description: options.description || '',
      objectives: [],
      inScope: [],
      outOfScope: [],
      deliverables: [],
      constraints: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    await fs.writeFile(scopePath, JSON.stringify(scope, null, 2));
    return { success: true, path: scopePath };
  }

  /**
   * Create requirements.json for Nefario
   * @param {string} projectName - Name of the project
   */
  async createRequirementsJson(projectName) {
    const workspacePath = path.join(this.projectsDir, projectName);
    const reqPath = path.join(workspacePath, 'requirements.json');

    const requirements = {
      version: '1.0.0',
      functional: [],
      nonFunctional: [],
      technical: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    await fs.writeFile(reqPath, JSON.stringify(requirements, null, 2));
    return { success: true, path: reqPath };
  }

  /**
   * Create assumptions.json (shared)
   * @param {string} projectName - Name of the project
   */
  async createAssumptionsJson(projectName) {
    const workspacePath = path.join(this.projectsDir, projectName);
    const assumptionsPath = path.join(workspacePath, 'assumptions.json');

    const assumptions = {
      version: '1.0.0',
      assumptions: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    await fs.writeFile(assumptionsPath, JSON.stringify(assumptions, null, 2));
    return { success: true, path: assumptionsPath };
  }

  /**
   * Create risks.json for Tom
   * @param {string} projectName - Name of the project
   */
  async createRisksJson(projectName) {
    const workspacePath = path.join(this.projectsDir, projectName);
    const risksPath = path.join(workspacePath, 'risks.json');

    const risks = {
      version: '1.0.0',
      risks: [],
      summary: {
        total: 0,
        bySeverity: { critical: 0, high: 0, medium: 0, low: 0 },
        byStatus: { identified: 0, mitigating: 0, mitigated: 0, accepted: 0 }
      },
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    await fs.writeFile(risksPath, JSON.stringify(risks, null, 2));
    return { success: true, path: risksPath };
  }

  /**
   * Create security files for Tom
   * @param {string} projectName - Name of the project
   */
  async createSecurityFiles(projectName) {
    const workspacePath = path.join(this.projectsDir, projectName);
    const securityDir = path.join(workspacePath, 'security');

    // Create threat-model.json
    const threatModel = {
      version: '1.0.0',
      threats: [],
      summary: {
        total: 0,
        byCategory: {},
        byStatus: { identified: 0, mitigated: 0, accepted: 0 }
      },
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    await fs.writeFile(
      path.join(securityDir, 'threat-model.json'),
      JSON.stringify(threatModel, null, 2)
    );

    // Create permissions.json
    const permissions = {
      version: '1.0.0',
      roles: [],
      permissions: [],
      assignments: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    await fs.writeFile(
      path.join(securityDir, 'permissions.json'),
      JSON.stringify(permissions, null, 2)
    );

    // Create audit-log.json
    const auditLog = {
      version: '1.0.0',
      entries: [],
      createdAt: new Date().toISOString()
    };
    await fs.writeFile(
      path.join(securityDir, 'audit-log.json'),
      JSON.stringify(auditLog, null, 2)
    );

    return { success: true, path: securityDir };
  }

  /**
   * Create ops files for Tom
   * @param {string} projectName - Name of the project
   */
  async createOpsFiles(projectName) {
    const workspacePath = path.join(this.projectsDir, projectName);
    const opsDir = path.join(workspacePath, 'ops');

    // Create environments.json
    const environments = {
      version: '1.0.0',
      environments: [
        { name: 'development', tier: 'development', status: 'active' },
        { name: 'staging', tier: 'staging', status: 'planned' },
        { name: 'production', tier: 'production', status: 'planned' }
      ],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    await fs.writeFile(
      path.join(opsDir, 'environments.json'),
      JSON.stringify(environments, null, 2)
    );

    return { success: true, path: opsDir };
  }

  /**
   * Create gaps.json for Lucy
   * @param {string} projectName - Name of the project
   */
  async createGapsJson(projectName) {
    const workspacePath = path.join(this.projectsDir, projectName);
    const gapsPath = path.join(workspacePath, 'gaps.json');

    const gaps = {
      version: '1.0.0',
      gaps: [],
      summary: {
        total: 0,
        byCategory: {},
        byPriority: { critical: 0, high: 0, medium: 0, low: 0 },
        byStatus: { detected: 0, inProgress: 0, resolved: 0 }
      },
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    await fs.writeFile(gapsPath, JSON.stringify(gaps, null, 2));
    return { success: true, path: gapsPath };
  }

  /**
   * Create quality files for Lucy
   * @param {string} projectName - Name of the project
   */
  async createQualityFiles(projectName) {
    const workspacePath = path.join(this.projectsDir, projectName);
    const qualityDir = path.join(workspacePath, 'quality');

    // Create test-coverage.json
    const testCoverage = {
      version: '1.0.0',
      coverage: {
        lines: 0,
        branches: 0,
        functions: 0,
        statements: 0
      },
      files: [],
      lastRun: null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    await fs.writeFile(
      path.join(qualityDir, 'test-coverage.json'),
      JSON.stringify(testCoverage, null, 2)
    );

    // Create code-quality.json
    const codeQuality = {
      version: '1.0.0',
      metrics: {
        complexity: 0,
        maintainability: 0,
        duplications: 0
      },
      issues: [],
      lastRun: null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    await fs.writeFile(
      path.join(qualityDir, 'code-quality.json'),
      JSON.stringify(codeQuality, null, 2)
    );

    // Create metrics.json
    const metrics = {
      version: '1.0.0',
      completion: {
        percentage: 0,
        trend: []
      },
      velocity: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    await fs.writeFile(
      path.join(qualityDir, 'metrics.json'),
      JSON.stringify(metrics, null, 2)
    );

    return { success: true, path: qualityDir };
  }

  /**
   * Remove project workspace (cleanup)
   * @param {string} projectName - Name of the project
   */
  async cleanup(projectName) {
    try {
      const workspacePath = path.join(this.projectsDir, projectName);

      // Verify it's a valid project workspace
      const configPath = path.join(workspacePath, '.minions', 'project.json');
      await fs.access(configPath);

      // Remove the entire workspace
      await fs.rm(workspacePath, { recursive: true, force: true });

      return { success: true, name: projectName };
    } catch (error) {
      if (error.code === 'ENOENT') {
        // Workspace doesn't exist - that's okay
        return { success: true, name: projectName, note: 'Workspace did not exist' };
      }
      this.emit('error', { method: 'cleanup', error: error.message });
      throw error;
    }
  }

  /**
   * Check if a project workspace exists
   * @param {string} projectName - Name of the project
   */
  async exists(projectName) {
    try {
      const workspacePath = path.join(this.projectsDir, projectName);
      const configPath = path.join(workspacePath, '.minions', 'project.json');
      await fs.access(configPath);
      return true;
    } catch (e) {
      return false;
    }
  }

  /**
   * Get project workspace path
   * @param {string} projectName - Name of the project
   */
  getWorkspacePath(projectName) {
    return path.join(this.projectsDir, projectName);
  }

  async shutdown() {
    this.removeAllListeners();
  }
}

export default ProjectInitializer;
