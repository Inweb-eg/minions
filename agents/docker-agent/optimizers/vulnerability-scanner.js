/**
 * VulnerabilityScanner - Scans Docker Images for Security Vulnerabilities
 *
 * Phase 8.4: Optimizers & Security
 * Scans Docker images for known security vulnerabilities
 */

import { BaseOptimizer, OPTIMIZATION_CATEGORY, OPTIMIZATION_LEVEL } from './base-optimizer.js';
import Docker from 'dockerode';

/**
 * Vulnerability severity levels
 */
export const VULNERABILITY_SEVERITY = {
  CRITICAL: 'critical',
  HIGH: 'high',
  MEDIUM: 'medium',
  LOW: 'low',
  NEGLIGIBLE: 'negligible'
};

/**
 * Scan status
 */
export const SCAN_STATUS = {
  CLEAN: 'clean',
  VULNERABLE: 'vulnerable',
  UNKNOWN: 'unknown'
};

/**
 * VulnerabilityScanner
 * Scans Docker images for vulnerabilities
 */
export class VulnerabilityScanner extends BaseOptimizer {
  constructor() {
    super('VulnerabilityScanner', 'security');
    this.docker = new Docker();
    this.knownVulnerablePackages = this.initializeKnownVulnerabilities();
  }

  /**
   * Initialize known vulnerabilities database (simplified)
   * In production, this would connect to CVE databases
   * @returns {Map} Known vulnerabilities
   */
  initializeKnownVulnerabilities() {
    const vulnerabilities = new Map();

    // Example vulnerable packages (for demonstration)
    vulnerabilities.set('log4j:2.14.1', {
      cve: 'CVE-2021-44228',
      severity: VULNERABILITY_SEVERITY.CRITICAL,
      description: 'Log4Shell RCE vulnerability',
      fixedIn: '2.17.1'
    });

    vulnerabilities.set('openssl:1.0.1', {
      cve: 'CVE-2014-0160',
      severity: VULNERABILITY_SEVERITY.CRITICAL,
      description: 'Heartbleed vulnerability',
      fixedIn: '1.0.1g'
    });

    return vulnerabilities;
  }

  /**
   * Analyze image for vulnerabilities
   * @param {Object} options - Analysis options
   * @returns {Promise<Object>} Analysis result
   */
  async analyze(options = {}) {
    const {
      tag,
      imageId,
      scanDepth = 'standard'  // 'quick', 'standard', 'deep'
    } = options;

    this.logger.info(`Scanning for vulnerabilities: ${tag || imageId} (depth: ${scanDepth})`);

    try {
      const image = this.docker.getImage(tag || imageId);
      const imageInfo = await image.inspect();

      const analysis = {
        status: SCAN_STATUS.CLEAN,
        vulnerabilities: [],
        summary: {
          critical: 0,
          high: 0,
          medium: 0,
          low: 0,
          negligible: 0
        },
        recommendations: []
      };

      // Scan base image
      const baseImageVulns = await this.scanBaseImage(imageInfo);
      analysis.vulnerabilities.push(...baseImageVulns);

      // Scan packages (simulated)
      const packageVulns = this.scanPackages(imageInfo);
      analysis.vulnerabilities.push(...packageVulns);

      // Scan configurations
      const configVulns = this.scanConfigurations(imageInfo);
      analysis.vulnerabilities.push(...configVulns);

      // Update summary
      analysis.vulnerabilities.forEach(vuln => {
        analysis.summary[vuln.severity]++;
      });

      // Determine status
      if (analysis.summary.critical > 0 || analysis.summary.high > 0) {
        analysis.status = SCAN_STATUS.VULNERABLE;
      } else if (analysis.vulnerabilities.length > 0) {
        analysis.status = SCAN_STATUS.VULNERABLE;
      }

      // Generate recommendations
      analysis.recommendations = this.generateSecurityRecommendations(analysis);

      return analysis;
    } catch (error) {
      this.logger.error(`Vulnerability scan failed: ${error.message}`);
      throw error;
    }
  }

  /**
   * Optimize security posture
   * @param {Object} options - Optimization options
   * @returns {Promise<Object>} Optimization result
   */
  async optimize(options = {}) {
    const {
      tag,
      imageId,
      level = OPTIMIZATION_LEVEL.MODERATE
    } = options;

    this.logger.info(`Optimizing security: ${tag || imageId} (level: ${level})`);

    // Scan first
    const analysis = await this.analyze({ tag, imageId });

    // Filter recommendations by level
    const applicableRecommendations = this.filterByLevel(analysis.recommendations, level);

    // Prioritize by severity
    const prioritized = this.prioritizeBySecuritySeverity(applicableRecommendations);

    const result = this.createResult({
      success: true,
      recommendations: prioritized,
      applied: [],
      skipped: [],
      metadata: {
        tag,
        imageId,
        scanStatus: analysis.status,
        vulnerabilitiesFound: analysis.vulnerabilities.length,
        critical: analysis.summary.critical,
        high: analysis.summary.high
      }
    });

    this.recordOptimization(result);
    return result;
  }

  /**
   * Scan base image for known vulnerabilities
   * @param {Object} imageInfo - Image info
   * @returns {Promise<Array>} Vulnerabilities
   */
  async scanBaseImage(imageInfo) {
    const vulnerabilities = [];

    // Extract base image from labels or config
    const baseImage = imageInfo.Config?.Image || 'unknown';

    // Check for outdated base images
    if (baseImage.includes(':latest')) {
      vulnerabilities.push({
        type: 'base_image',
        severity: VULNERABILITY_SEVERITY.MEDIUM,
        title: 'Using :latest tag',
        description: 'Base image uses :latest tag which may pull vulnerable versions',
        recommendation: 'Pin to specific version tag',
        fixedIn: null
      });
    }

    // Check for known vulnerable base images (simulated)
    if (baseImage.includes('ubuntu:14.04') || baseImage.includes('debian:7')) {
      vulnerabilities.push({
        type: 'base_image',
        severity: VULNERABILITY_SEVERITY.HIGH,
        title: 'Unsupported base image',
        description: 'Base image version is end-of-life and no longer receives security updates',
        recommendation: 'Upgrade to a supported version',
        fixedIn: 'ubuntu:20.04 or debian:11'
      });
    }

    return vulnerabilities;
  }

  /**
   * Scan packages for vulnerabilities (simulated)
   * @param {Object} imageInfo - Image info
   * @returns {Array} Vulnerabilities
   */
  scanPackages(imageInfo) {
    const vulnerabilities = [];

    // In a real implementation, this would:
    // 1. Extract package list from image
    // 2. Query CVE databases (NVD, etc.)
    // 3. Match against known vulnerabilities

    // Simulated scan based on environment variables or labels
    const env = imageInfo.Config?.Env || [];

    env.forEach(envVar => {
      // Check for potentially vulnerable packages mentioned in env
      if (envVar.includes('NODE_VERSION=14.')) {
        vulnerabilities.push({
          type: 'package',
          severity: VULNERABILITY_SEVERITY.MEDIUM,
          title: 'Outdated Node.js version',
          description: 'Node.js 14.x has known vulnerabilities',
          recommendation: 'Upgrade to Node.js 18 LTS or higher',
          package: 'node',
          currentVersion: '14.x',
          fixedIn: '18.x'
        });
      }
    });

    return vulnerabilities;
  }

  /**
   * Scan configurations for security issues
   * @param {Object} imageInfo - Image info
   * @returns {Array} Vulnerabilities
   */
  scanConfigurations(imageInfo) {
    const vulnerabilities = [];

    // Check if running as root
    if (!imageInfo.Config?.User || imageInfo.Config.User === 'root' || imageInfo.Config.User === '0') {
      vulnerabilities.push({
        type: 'configuration',
        severity: VULNERABILITY_SEVERITY.HIGH,
        title: 'Container runs as root',
        description: 'Running containers as root poses security risks',
        recommendation: 'Add USER instruction to run as non-root user',
        cwe: 'CWE-250: Execution with Unnecessary Privileges'
      });
    }

    // Check for exposed secrets in environment
    const env = imageInfo.Config?.Env || [];
    env.forEach(envVar => {
      const lower = envVar.toLowerCase();
      if (
        (lower.includes('password=') ||
        lower.includes('secret=') ||
        lower.includes('token=') ||
        lower.includes('api_key=')) &&
        !lower.includes('${')  // Not a variable reference
      ) {
        vulnerabilities.push({
          type: 'configuration',
          severity: VULNERABILITY_SEVERITY.CRITICAL,
          title: 'Hardcoded secrets in environment',
          description: 'Secrets should not be hardcoded in Docker images',
          recommendation: 'Use Docker secrets or environment variable injection at runtime',
          cwe: 'CWE-798: Use of Hard-coded Credentials'
        });
      }
    });

    // Check for security options
    if (!imageInfo.Config?.SecurityOpt || imageInfo.Config.SecurityOpt.length === 0) {
      vulnerabilities.push({
        type: 'configuration',
        severity: VULNERABILITY_SEVERITY.LOW,
        title: 'No security options configured',
        description: 'Container has no additional security options',
        recommendation: 'Consider enabling AppArmor, SELinux, or seccomp profiles',
        cwe: 'CWE-1188: Insecure Default Initialization of Resource'
      });
    }

    return vulnerabilities;
  }

  /**
   * Generate security recommendations
   * @param {Object} analysis - Security analysis
   * @returns {Array} Recommendations
   */
  generateSecurityRecommendations(analysis) {
    const recommendations = [];

    // Critical vulnerabilities
    const critical = analysis.vulnerabilities.filter(v => v.severity === VULNERABILITY_SEVERITY.CRITICAL);
    if (critical.length > 0) {
      recommendations.push(this.createRecommendation({
        category: OPTIMIZATION_CATEGORY.SECURITY,
        level: OPTIMIZATION_LEVEL.AGGRESSIVE,
        description: `Fix ${critical.length} critical vulnerability/vulnerabilities immediately`,
        impact: 'high',
        effort: 'high',
        implementation: critical.map(v => `- ${v.title}: ${v.recommendation}`).join('\n')
      }));
    }

    // High vulnerabilities
    const high = analysis.vulnerabilities.filter(v => v.severity === VULNERABILITY_SEVERITY.HIGH);
    if (high.length > 0) {
      recommendations.push(this.createRecommendation({
        category: OPTIMIZATION_CATEGORY.SECURITY,
        level: OPTIMIZATION_LEVEL.MODERATE,
        description: `Address ${high.length} high severity vulnerability/vulnerabilities`,
        impact: 'high',
        effort: 'medium',
        implementation: high.map(v => `- ${v.title}: ${v.recommendation}`).join('\n')
      }));
    }

    // General security hardening
    if (analysis.vulnerabilities.length > 0) {
      recommendations.push(this.createRecommendation({
        category: OPTIMIZATION_CATEGORY.SECURITY,
        level: OPTIMIZATION_LEVEL.MINIMAL,
        description: 'Implement security best practices',
        impact: 'medium',
        effort: 'low',
        implementation: 'Run as non-root user, use minimal base images, scan regularly'
      }));
    }

    return recommendations;
  }

  /**
   * Prioritize recommendations by security severity
   * @param {Array} recommendations - Recommendations
   * @returns {Array} Prioritized recommendations
   */
  prioritizeBySecuritySeverity(recommendations) {
    const severityWeight = {
      critical: 5,
      high: 4,
      medium: 3,
      low: 2,
      negligible: 1
    };

    return recommendations.sort((a, b) => {
      const weightA = severityWeight[a.metadata?.severity] || 0;
      const weightB = severityWeight[b.metadata?.severity] || 0;
      return weightB - weightA;
    });
  }

  /**
   * Generate security report
   * @param {Object} analysis - Security analysis
   * @returns {string} Formatted report
   */
  generateSecurityReport(analysis) {
    const lines = [];

    lines.push('Security Scan Report');
    lines.push('='.repeat(50));
    lines.push(`Status: ${analysis.status.toUpperCase()}`);
    lines.push(`Total Vulnerabilities: ${analysis.vulnerabilities.length}`);
    lines.push('');

    lines.push('Summary:');
    lines.push(`  Critical: ${analysis.summary.critical}`);
    lines.push(`  High: ${analysis.summary.high}`);
    lines.push(`  Medium: ${analysis.summary.medium}`);
    lines.push(`  Low: ${analysis.summary.low}`);
    lines.push(`  Negligible: ${analysis.summary.negligible}`);
    lines.push('');

    if (analysis.vulnerabilities.length > 0) {
      lines.push('Vulnerabilities:');
      analysis.vulnerabilities.forEach((vuln, index) => {
        lines.push(`  ${index + 1}. [${vuln.severity.toUpperCase()}] ${vuln.title}`);
        lines.push(`     ${vuln.description}`);
        if (vuln.recommendation) {
          lines.push(`     Fix: ${vuln.recommendation}`);
        }
        if (vuln.cve) {
          lines.push(`     CVE: ${vuln.cve}`);
        }
        lines.push('');
      });
    }

    if (analysis.recommendations.length > 0) {
      lines.push('Recommendations:');
      analysis.recommendations.forEach((rec, index) => {
        lines.push(`  ${index + 1}. ${rec.description}`);
        lines.push(`     Impact: ${rec.impact} | Effort: ${rec.effort}`);
        lines.push('');
      });
    }

    return lines.join('\n');
  }

  /**
   * Check if scan is clean
   * @param {Object} analysis - Security analysis
   * @param {string} threshold - Severity threshold
   * @returns {boolean} Is clean
   */
  isClean(analysis, threshold = VULNERABILITY_SEVERITY.MEDIUM) {
    const thresholds = ['critical', 'high', 'medium', 'low', 'negligible'];
    const thresholdIndex = thresholds.indexOf(threshold);

    for (let i = 0; i <= thresholdIndex; i++) {
      if (analysis.summary[thresholds[i]] > 0) {
        return false;
      }
    }

    return true;
  }
}

/**
 * Get singleton instance
 */
let scannerInstance = null;

export function getVulnerabilityScanner() {
  if (!scannerInstance) {
    scannerInstance = new VulnerabilityScanner();
  }
  return scannerInstance;
}
