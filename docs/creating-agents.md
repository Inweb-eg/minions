# Creating Agents Guide

Comprehensive guide for creating custom agents in the Minions framework.

## Table of Contents

- [Agent Basics](#agent-basics)
- [Agent Patterns](#agent-patterns)
- [Event Handling](#event-handling)
- [Error Handling](#error-handling)
- [Testing Agents](#testing-agents)
- [Best Practices](#best-practices)

---

## Agent Basics

### What is an Agent?

An agent is an autonomous unit that:
- Performs a specific task or set of related tasks
- Communicates via the EventBus
- Can depend on other agents
- Has a lifecycle (initialize → execute → cleanup)

### Minimum Agent Requirements

An agent must have at least one of these execution methods:
- `execute()` - Standard execution
- `run()` - Alias for compatibility
- `analyze()` - For analyzer-type agents

```javascript
class MinimalAgent {
  constructor() {
    this.name = 'minimal-agent';
  }

  async execute() {
    console.log('Agent executing');
    return { success: true };
  }
}
```

### Agent Registration

```javascript
import { getOrchestrator } from 'minions';

const orchestrator = getOrchestrator();

// Register with a loader function
orchestrator.registerAgent(
  'my-agent',                        // Unique name
  async () => new MyAgent(),         // Loader function
  ['dependency-agent']               // Dependencies (optional)
);
```

---

## Agent Patterns

### Pattern 1: Simple Functional Agent

Best for straightforward tasks:

```javascript
import { createAgent, EventTypes } from 'minions';

const dataFetcher = createAgent({
  name: 'data-fetcher',
  execute: async () => {
    const data = await fetchDataFromAPI();
    return { success: true, records: data.length };
  }
});

// Register
orchestrator.registerAgent('data-fetcher', async () => dataFetcher, []);
```

### Pattern 2: Class-Based Agent

Best for complex agents with state:

```javascript
import { getEventBus, EventTypes, createLogger } from 'minions';

const logger = createLogger('DataProcessor');

class DataProcessor {
  constructor(options = {}) {
    this.name = 'data-processor';
    this.eventBus = getEventBus();
    this.config = options.config || {};
    this.unsubscribers = [];
  }

  async initialize() {
    if (this.initialized) return;

    logger.info('Initializing...');

    // Subscribe to events
    this.subscribeToEvents();

    // Setup resources
    await this.setupDatabase();

    this.initialized = true;
    logger.info('Initialized');
  }

  subscribeToEvents() {
    this.unsubscribers.push(
      this.eventBus.subscribe(
        EventTypes.CODE_GENERATED,
        this.name,
        this.handleCodeGenerated.bind(this)
      )
    );
  }

  async handleCodeGenerated(data) {
    logger.info(`Code generated by ${data.agent}`);
    // React to event
  }

  async execute() {
    const startTime = Date.now();

    try {
      await this.initialize();

      // Publish started event
      this.eventBus.publish(EventTypes.AGENT_STARTED, {
        agent: this.name,
        timestamp: startTime
      });

      // Main work
      const result = await this.doWork();

      const duration = Date.now() - startTime;

      // Publish completed event
      this.eventBus.publish(EventTypes.AGENT_COMPLETED, {
        agent: this.name,
        execution_time_ms: duration
      });

      logger.info(`Completed in ${duration}ms`);
      return { success: true, duration, ...result };

    } catch (error) {
      const duration = Date.now() - startTime;

      // Publish failed event
      this.eventBus.publish(EventTypes.AGENT_FAILED, {
        agent: this.name,
        error: error.message,
        execution_time_ms: duration
      });

      logger.error('Failed:', error);
      throw error;
    }
  }

  async doWork() {
    // Your main logic here
    return { processed: 100 };
  }

  async cleanup() {
    logger.info('Cleaning up...');
    this.unsubscribers.forEach(fn => fn());
    this.unsubscribers = [];
    this.initialized = false;
  }

  // Aliases for compatibility
  async run() { return this.execute(); }
  async analyze() { return this.execute(); }
}

// Singleton pattern
let instance = null;
export function getDataProcessor(options) {
  if (!instance) {
    instance = new DataProcessor(options);
  }
  return instance;
}

export default DataProcessor;
```

### Pattern 3: Event-Reactive Agent

Agent that primarily responds to events:

```javascript
import { getEventBus, EventTypes, createLogger } from 'minions';

const logger = createLogger('AutoFixAgent');

class AutoFixAgent {
  constructor() {
    this.name = 'auto-fix-agent';
    this.eventBus = getEventBus();
    this.unsubscribers = [];
    this.pendingFixes = [];
  }

  async initialize() {
    // Subscribe to fix requests
    this.unsubscribers.push(
      this.eventBus.subscribe(
        EventTypes.AUTO_FIX_REQUESTED,
        this.name,
        this.handleFixRequest.bind(this)
      )
    );

    logger.info('Ready to receive fix requests');
  }

  async handleFixRequest(data) {
    // Only handle requests targeted at this agent
    if (data.targetAgent !== this.name) return;

    logger.info(`Received ${data.tasks?.length || 0} fix tasks`);

    const results = [];
    for (const task of data.tasks || []) {
      try {
        const result = await this.fixTask(task);
        results.push({ task, success: true, result });
      } catch (error) {
        results.push({ task, success: false, error: error.message });
        logger.error(`Failed to fix task: ${error.message}`);
      }
    }

    // Publish completion
    this.eventBus.publish(EventTypes.FIX_COMPLETED, {
      agent: this.name,
      loopId: data.loopId,
      results,
      tasksCompleted: results.filter(r => r.success).length,
      tasksFailed: results.filter(r => !r.success).length
    });
  }

  async fixTask(task) {
    logger.info(`Fixing: ${task.test || task.name}`);
    // Fix logic here
    return { fixed: true };
  }

  async execute() {
    await this.initialize();

    // Event-reactive agents may not have main work
    // They wait for events
    logger.info('Agent ready, waiting for events');

    return { success: true };
  }

  async cleanup() {
    this.unsubscribers.forEach(fn => fn());
  }
}

export default AutoFixAgent;
```

### Pattern 4: Skill-Based Agent

Agent that uses built-in skills:

```javascript
import {
  getEventBus,
  EventTypes,
  createLogger,
  getCodeReviewer,
  getSecurityScanner
} from 'minions';

const logger = createLogger('QualityAgent');

class QualityAgent {
  constructor(options = {}) {
    this.name = 'quality-agent';
    this.eventBus = getEventBus();
    this.projectRoot = options.projectRoot || process.cwd();
  }

  async initialize() {
    // Initialize skills
    this.codeReviewer = getCodeReviewer();
    this.securityScanner = getSecurityScanner();

    await this.codeReviewer.initialize();
    await this.securityScanner.initialize();

    logger.info('Skills initialized');
  }

  async execute() {
    await this.initialize();

    // Get files to analyze
    const files = await this.getChangedFiles();

    const results = {
      reviews: [],
      securityIssues: []
    };

    // Review each file
    for (const file of files) {
      const review = await this.codeReviewer.review(file);
      results.reviews.push({ file, ...review });
    }

    // Security scan
    const securityResults = await this.securityScanner.scan(this.projectRoot);
    results.securityIssues = securityResults.issues;

    // Publish results
    this.eventBus.publish(EventTypes.CODE_ANALYZED, {
      agent: this.name,
      results
    });

    // Publish quality score
    this.eventBus.publish(EventTypes.QUALITY_SCORED, {
      agent: this.name,
      score: this.calculateOverallScore(results)
    });

    return { success: true, results };
  }

  async getChangedFiles() {
    // Get files from git or configuration
    return ['src/index.js'];
  }

  calculateOverallScore(results) {
    const avgReviewScore = results.reviews.reduce(
      (sum, r) => sum + r.qualityScore, 0
    ) / results.reviews.length;

    // Reduce score for security issues
    const securityPenalty = results.securityIssues.length * 5;

    return Math.max(0, avgReviewScore - securityPenalty);
  }
}

export default QualityAgent;
```

---

## Event Handling

### Standard Event Lifecycle

```javascript
class MyAgent {
  async execute() {
    const startTime = Date.now();

    // 1. Publish STARTED
    this.eventBus.publish(EventTypes.AGENT_STARTED, {
      agent: this.name,
      timestamp: startTime
    });

    try {
      // 2. Do work
      const result = await this.doWork();

      // 3. Publish domain-specific events
      this.eventBus.publish(EventTypes.CODE_ANALYZED, {
        agent: this.name,
        results: result
      });

      // 4. Publish COMPLETED
      this.eventBus.publish(EventTypes.AGENT_COMPLETED, {
        agent: this.name,
        execution_time_ms: Date.now() - startTime
      });

      return result;

    } catch (error) {
      // 5. Publish FAILED on error
      this.eventBus.publish(EventTypes.AGENT_FAILED, {
        agent: this.name,
        error: error.message,
        execution_time_ms: Date.now() - startTime
      });

      throw error;
    }
  }
}
```

### Subscribing to Events

```javascript
class MyAgent {
  subscribeToEvents() {
    // Subscribe with binding
    this.unsubscribers.push(
      this.eventBus.subscribe(
        EventTypes.TESTS_FAILED,
        this.name,
        this.handleTestsFailed.bind(this)
      )
    );

    // Subscribe to multiple events
    const events = [
      EventTypes.CODE_GENERATED,
      EventTypes.CODE_UPDATED
    ];

    events.forEach(eventType => {
      this.unsubscribers.push(
        this.eventBus.subscribe(
          eventType,
          this.name,
          this.handleCodeChange.bind(this)
        )
      );
    });
  }

  handleTestsFailed(data, event) {
    // data: Event payload
    // event: Full event object with id, timestamp, type
  }

  async cleanup() {
    // Always unsubscribe
    this.unsubscribers.forEach(fn => fn());
    this.unsubscribers = [];
  }
}
```

### Event Data Guidelines

```javascript
// Good: Include agent name and relevant data
this.eventBus.publish(EventTypes.CODE_GENERATED, {
  agent: this.name,
  files: ['src/api.js', 'src/utils.js'],
  linesGenerated: 250,
  timestamp: Date.now()
});

// Good: Include context for failures
this.eventBus.publish(EventTypes.TESTS_FAILED, {
  agent: this.name,
  failures: [
    {
      file: 'src/__tests__/api.test.js',
      testName: 'should return user',
      error: 'Expected 200, got 404'
    }
  ],
  summary: {
    total: 10,
    passed: 8,
    failed: 2
  }
});
```

---

## Error Handling

### Try-Catch Pattern

```javascript
class MyAgent {
  async execute() {
    try {
      const result = await this.riskyOperation();
      return { success: true, result };
    } catch (error) {
      this.logger.error('Execution failed:', error);

      // Publish failure event
      this.eventBus.publish(EventTypes.AGENT_FAILED, {
        agent: this.name,
        error: error.message,
        stack: error.stack
      });

      // Re-throw for orchestrator
      throw error;
    }
  }
}
```

### Graceful Degradation

```javascript
class MyAgent {
  async execute() {
    const results = {
      primary: null,
      secondary: null,
      errors: []
    };

    // Primary task - critical
    try {
      results.primary = await this.primaryTask();
    } catch (error) {
      this.logger.error('Primary task failed:', error);
      throw error;  // Fail the agent
    }

    // Secondary task - optional
    try {
      results.secondary = await this.secondaryTask();
    } catch (error) {
      this.logger.warn('Secondary task failed:', error);
      results.errors.push({ task: 'secondary', error: error.message });
      // Continue despite error
    }

    return results;
  }
}
```

### Retry Logic

```javascript
class MyAgent {
  async executeWithRetry(fn, maxRetries = 3, delay = 1000) {
    let lastError;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error;
        this.logger.warn(`Attempt ${attempt} failed: ${error.message}`);

        if (attempt < maxRetries) {
          await this.sleep(delay * Math.pow(2, attempt - 1));
        }
      }
    }

    throw lastError;
  }

  async execute() {
    return this.executeWithRetry(async () => {
      return await this.fetchData();
    });
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

---

## Testing Agents

### Unit Test Structure

```javascript
import { jest, describe, beforeEach, afterEach, test, expect } from '@jest/globals';
import { getEventBus } from '../foundation/event-bus/AgentEventBus.js';
import { EventTypes } from '../foundation/event-bus/eventTypes.js';
import MyAgent from './MyAgent.js';

describe('MyAgent', () => {
  let agent;
  let eventBus;

  beforeEach(async () => {
    eventBus = getEventBus();
    agent = new MyAgent();
    await agent.initialize();
  });

  afterEach(() => {
    eventBus.clearHistory();
    if (agent.cleanup) {
      agent.cleanup();
    }
  });

  test('should execute successfully', async () => {
    const result = await agent.execute();

    expect(result.success).toBe(true);
  });

  test('should publish AGENT_COMPLETED event', async () => {
    await agent.execute();

    const events = eventBus.getHistory({
      eventType: EventTypes.AGENT_COMPLETED
    });

    expect(events).toHaveLength(1);
    expect(events[0].data.agent).toBe(agent.name);
  });

  test('should handle errors gracefully', async () => {
    // Mock a failing dependency
    agent.riskyOperation = jest.fn().mockRejectedValue(
      new Error('Test error')
    );

    await expect(agent.execute()).rejects.toThrow('Test error');

    const failEvents = eventBus.getHistory({
      eventType: EventTypes.AGENT_FAILED
    });

    expect(failEvents).toHaveLength(1);
  });
});
```

### Integration Test

```javascript
import { initializeMinions, createAgent, EventTypes } from '../index.js';

describe('Agent Integration', () => {
  let orchestrator, eventBus;

  beforeEach(async () => {
    const components = await initializeMinions();
    orchestrator = components.orchestrator;
    eventBus = components.eventBus;
  });

  test('should execute agents in dependency order', async () => {
    const executionOrder = [];

    const agentA = createAgent({
      name: 'agent-a',
      execute: async () => { executionOrder.push('a'); }
    });

    const agentB = createAgent({
      name: 'agent-b',
      execute: async () => { executionOrder.push('b'); }
    });

    orchestrator.registerAgent('agent-a', async () => agentA, []);
    orchestrator.registerAgent('agent-b', async () => agentB, ['agent-a']);

    await orchestrator.execute();

    expect(executionOrder).toEqual(['a', 'b']);
  });
});
```

---

## Best Practices

### 1. Use Meaningful Names

```javascript
// Good
class UserAuthenticationAgent { ... }
class DatabaseMigrationAgent { ... }

// Bad
class Agent1 { ... }
class ProcessorAgent { ... }
```

### 2. Keep Agents Focused

```javascript
// Good: Single responsibility
class ValidationAgent {
  async execute() {
    return this.validateInputs();
  }
}

// Bad: Too many responsibilities
class DoEverythingAgent {
  async execute() {
    await this.fetchData();
    await this.validateData();
    await this.transformData();
    await this.saveData();
    await this.sendNotifications();
  }
}
```

### 3. Use Logging Appropriately

```javascript
import { createLogger } from 'minions';

const logger = createLogger('MyAgent');

class MyAgent {
  async execute() {
    logger.info('Starting execution');         // Info: Major milestones
    logger.debug('Processing item:', item);    // Debug: Detailed info
    logger.warn('Retrying operation');         // Warn: Recoverable issues
    logger.error('Failed:', error);            // Error: Failures
  }
}
```

### 4. Clean Up Resources

```javascript
class MyAgent {
  async initialize() {
    this.dbConnection = await connectToDatabase();
    this.subscribeToEvents();
  }

  async cleanup() {
    // Always clean up subscriptions
    this.unsubscribers.forEach(fn => fn());

    // Close connections
    if (this.dbConnection) {
      await this.dbConnection.close();
    }

    // Clear state
    this.initialized = false;
  }
}
```

### 5. Document Dependencies

```javascript
/**
 * UserSyncAgent
 *
 * Syncs user data between systems.
 *
 * Dependencies:
 * - auth-agent: Provides authentication tokens
 * - database-agent: Provides database connection
 *
 * Events Published:
 * - USER_SYNCED: When a user is successfully synced
 *
 * Events Consumed:
 * - USER_CREATED: Triggers sync for new users
 */
class UserSyncAgent { ... }
```

### 6. Make Configuration Explicit

```javascript
class MyAgent {
  constructor(options = {}) {
    this.name = options.name || 'my-agent';
    this.config = {
      timeout: options.timeout || 30000,
      retries: options.retries || 3,
      batchSize: options.batchSize || 100
    };
  }
}

// Usage
const agent = new MyAgent({
  timeout: 60000,
  batchSize: 50
});
```

### 7. Use Type-Safe Event Data

```javascript
// Define event data structures
const TestFailedData = {
  agent: 'string',
  failures: [{
    file: 'string',
    testName: 'string',
    error: 'string',
    location: { line: 'number', column: 'number' }
  }],
  summary: {
    total: 'number',
    passed: 'number',
    failed: 'number'
  }
};

// Validate before publishing
this.eventBus.publish(EventTypes.TESTS_FAILED, {
  agent: this.name,
  failures: validatedFailures,
  summary: { total: 10, passed: 8, failed: 2 }
});
```
