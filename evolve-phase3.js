#!/usr/bin/env node
/**
 * Minions Self-Evolution - Phase 3: Code Generation
 *
 * This phase takes the decomposed tasks from Phase 2 and:
 * 1. Assigns tasks to specialized writer agents
 * 2. Generates code for each component
 * 3. Validates generated code against architecture
 *
 * Usage: node evolve-phase3.js
 */

import { initializeMinions, getEventBus } from './index.js';
import fs from 'fs/promises';
import path from 'path';

// Colors for console output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  green: '\x1b[32m',
  magenta: '\x1b[35m',
  red: '\x1b[31m',
  blue: '\x1b[34m',
  gray: '\x1b[90m'
};

const log = {
  kevin: (msg) => console.log(`${colors.yellow}ğŸ‘‘ Kevin:${colors.reset} ${msg}`),
  bob: (msg) => console.log(`${colors.cyan}ğŸ§¸ Bob:${colors.reset} ${msg}`),
  stuart: (msg) => console.log(`${colors.magenta}ğŸ¸ Stuart:${colors.reset} ${msg}`),
  carl: (msg) => console.log(`${colors.blue}ğŸ’» Carl (Backend):${colors.reset} ${msg}`),
  otto: (msg) => console.log(`${colors.cyan}ğŸ“± Otto (Mobile):${colors.reset} ${msg}`),
  larry: (msg) => console.log(`${colors.green}ğŸ¨ Larry (Frontend):${colors.reset} ${msg}`),
  vector: (msg) => console.log(`${colors.red}ğŸ›¡ï¸ Vector (Security):${colors.reset} ${msg}`),
  system: (msg) => console.log(`${colors.bright}âš™ï¸ System:${colors.reset} ${msg}`),
  event: (msg) => console.log(`${colors.magenta}ğŸ”” Event:${colors.reset} ${msg}`),
  error: (msg) => console.log(`${colors.red}âŒ Error:${colors.reset} ${msg}`),
  success: (msg) => console.log(`${colors.green}âœ… Success:${colors.reset} ${msg}`),
  code: (msg) => console.log(`${colors.gray}   ${msg}${colors.reset}`),
  file: (msg) => console.log(`${colors.green}   ğŸ“„ ${msg}${colors.reset}`)
};

// Banner
console.log(`
${colors.yellow}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${colors.reset}
${colors.green}    ____  _   _    _    ____  _____   _____ ${colors.reset}
${colors.green}   |  _ \\| | | |  / \\  / ___|| ____| |___ / ${colors.reset}
${colors.green}   | |_) | |_| | / _ \\ \\___ \\|  _|     |_ \\ ${colors.reset}
${colors.green}   |  __/|  _  |/ ___ \\ ___) | |___   ___) |${colors.reset}
${colors.green}   |_|   |_| |_/_/   \\_\\____/|_____| |____/ ${colors.reset}
${colors.yellow}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${colors.reset}
${colors.bright}              Code Generation & Task Assignment${colors.reset}
${colors.yellow}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${colors.reset}
`);

// Simulated code generation results (since we don't have actual LLM integration)
function generateMockCode(taskName, taskType) {
  const templates = {
    backend: {
      service: `
/**
 * ${taskName} Service
 * Auto-generated by Minions v3.0
 */
export class ${toPascalCase(taskName)}Service {
  constructor(dependencies) {
    this.db = dependencies.db;
    this.logger = dependencies.logger;
  }

  async execute(params) {
    this.logger.info('Executing ${taskName}');
    // Implementation here
    return { success: true, data: params };
  }
}`,
      controller: `
/**
 * ${taskName} Controller
 * Auto-generated by Minions v3.0
 */
export class ${toPascalCase(taskName)}Controller {
  constructor(service) {
    this.service = service;
  }

  async handle(req, res) {
    try {
      const result = await this.service.execute(req.body);
      res.json(result);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
}`,
      test: `
/**
 * ${taskName} Tests
 * Auto-generated by Minions v3.0
 */
import { describe, it, expect } from 'jest';

describe('${taskName}', () => {
  it('should execute successfully', async () => {
    // Test implementation
    expect(true).toBe(true);
  });

  it('should handle errors gracefully', async () => {
    // Error handling test
    expect(true).toBe(true);
  });
});`
    },
    frontend: {
      component: `
/**
 * ${taskName} Component
 * Auto-generated by Minions v3.0
 */
import React from 'react';

export function ${toPascalCase(taskName)}({ data, onAction }) {
  return (
    <div className="${toKebabCase(taskName)}">
      <h2>${taskName}</h2>
      <button onClick={onAction}>Execute</button>
    </div>
  );
}`,
      hook: `
/**
 * use${toPascalCase(taskName)} Hook
 * Auto-generated by Minions v3.0
 */
import { useState, useCallback } from 'react';

export function use${toPascalCase(taskName)}() {
  const [state, setState] = useState(null);
  const [loading, setLoading] = useState(false);

  const execute = useCallback(async (params) => {
    setLoading(true);
    try {
      // API call here
      setState({ success: true });
    } finally {
      setLoading(false);
    }
  }, []);

  return { state, loading, execute };
}`
    },
    mobile: {
      widget: `
/// ${taskName} Widget
/// Auto-generated by Minions v3.0
import 'package:flutter/material.dart';

class ${toPascalCase(taskName)}Widget extends StatelessWidget {
  final VoidCallback? onTap;

  const ${toPascalCase(taskName)}Widget({Key? key, this.onTap}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Card(
      child: ListTile(
        title: Text('${taskName}'),
        onTap: onTap,
      ),
    );
  }
}`,
      provider: `
/// ${taskName} Provider
/// Auto-generated by Minions v3.0
import 'package:flutter/foundation.dart';

class ${toPascalCase(taskName)}Provider extends ChangeNotifier {
  bool _loading = false;
  bool get loading => _loading;

  Future<void> execute() async {
    _loading = true;
    notifyListeners();

    try {
      // Implementation here
      await Future.delayed(Duration(milliseconds: 100));
    } finally {
      _loading = false;
      notifyListeners();
    }
  }
}`
    }
  };

  // Determine which template to use based on task type
  if (taskName.toLowerCase().includes('test')) {
    return { code: templates.backend.test, type: 'test', lang: 'javascript' };
  } else if (taskName.toLowerCase().includes('api') || taskName.toLowerCase().includes('service')) {
    return { code: templates.backend.service, type: 'service', lang: 'javascript' };
  } else if (taskName.toLowerCase().includes('ui') || taskName.toLowerCase().includes('component')) {
    return { code: templates.frontend.component, type: 'component', lang: 'jsx' };
  } else if (taskName.toLowerCase().includes('mobile') || taskName.toLowerCase().includes('widget')) {
    return { code: templates.mobile.widget, type: 'widget', lang: 'dart' };
  } else {
    return { code: templates.backend.service, type: 'service', lang: 'javascript' };
  }
}

function toPascalCase(str) {
  return str.replace(/[^a-zA-Z0-9]+(.)/g, (_, chr) => chr.toUpperCase())
    .replace(/^[a-z]/, (chr) => chr.toUpperCase())
    .replace(/[^a-zA-Z0-9]/g, '');
}

function toKebabCase(str) {
  return str.toLowerCase().replace(/[^a-zA-Z0-9]+/g, '-').replace(/^-|-$/g, '');
}

async function main() {
  try {
    // Step 1: Initialize Minions
    log.kevin('Phase 3 starting! Time to write some code! ğŸŒ');
    console.log();

    log.system('Initializing Minions Framework with Writer Agents...');
    const eventBus = getEventBus();

    // Monitor code generation events
    eventBus.subscribe('*', 'Phase3Monitor', (data, event) => {
      if (event.type.includes('code:') || event.type.includes('planner:task')) {
        log.event(`[${event.type}] ${data?.agent || ''}`);
      }
    });

    const minions = await initializeMinions({
      enableVisionAgent: true,
      enableArchitectAgent: true,
      enablePlannerAgent: true,
      enableWriterAgents: true,
      enableMemoryStore: true,
      enableDecisionLogger: true,
      enableMetrics: true,
      enableHealth: true,
      projectRoot: process.cwd(),
      maxConcurrency: 5
    });

    log.success('All agents initialized!');
    console.log();

    // Step 2: Load Phase 2 data
    log.kevin('Loading decomposed tasks from Phase 2...');

    let phase2Data = null;
    if (minions.memoryStore) {
      phase2Data = await minions.memoryStore.get('evolution', 'phase2-decomposition');
    }

    if (!phase2Data) {
      log.system('No Phase 2 data found in memory, loading from Vision Agent...');
      const features = minions.visionAgent.getFeatures();
      const epics = minions.visionAgent.getEpics();
      const stories = minions.visionAgent.getStories();
      const tasks = minions.visionAgent.getTasks();

      phase2Data = { epics, stories, tasks, features };
    }

    const taskCount = phase2Data.tasks?.length || 0;
    const storyCount = phase2Data.stories?.length || 0;
    const epicCount = phase2Data.epics?.length || 0;

    log.success(`Loaded: ${epicCount} epics, ${storyCount} stories, ${taskCount} tasks`);
    console.log();

    // Step 3: Create output directory for generated code
    const outputDir = path.join(process.cwd(), 'generated', 'v3.0');
    await fs.mkdir(outputDir, { recursive: true });
    await fs.mkdir(path.join(outputDir, 'backend', 'src', 'services'), { recursive: true });
    await fs.mkdir(path.join(outputDir, 'backend', 'src', 'controllers'), { recursive: true });
    await fs.mkdir(path.join(outputDir, 'backend', 'tests'), { recursive: true });
    await fs.mkdir(path.join(outputDir, 'frontend', 'src', 'components'), { recursive: true });
    await fs.mkdir(path.join(outputDir, 'frontend', 'src', 'hooks'), { recursive: true });
    await fs.mkdir(path.join(outputDir, 'mobile', 'lib', 'widgets'), { recursive: true });
    await fs.mkdir(path.join(outputDir, 'mobile', 'lib', 'providers'), { recursive: true });

    log.system(`Output directory: ${outputDir}`);
    console.log();

    // Step 4: Assign and execute tasks
    log.kevin('Alright team! Carl handles backend, Otto handles mobile, Larry handles frontend!');
    console.log();

    const generationResults = {
      backend: { files: [], lines: 0 },
      frontend: { files: [], lines: 0 },
      mobile: { files: [], lines: 0 },
      tests: { files: [], lines: 0 },
      total: { files: 0, lines: 0, errors: 0 }
    };

    // Process stories (each story generates code)
    const storiesToProcess = (phase2Data.stories || []).slice(0, 12); // Process first 12 for demo
    let processedCount = 0;

    for (const story of storiesToProcess) {
      processedCount++;
      const progress = `[${processedCount}/${storiesToProcess.length}]`;

      try {
        // Determine which agent handles this
        let agent = 'carl';
        let category = 'backend';

        if (story.name.toLowerCase().includes('ui') || story.name.toLowerCase().includes('component')) {
          agent = 'larry';
          category = 'frontend';
        } else if (story.name.toLowerCase().includes('mobile') || story.name.toLowerCase().includes('widget')) {
          agent = 'otto';
          category = 'mobile';
        } else if (story.name.toLowerCase().includes('test')) {
          category = 'tests';
        }

        // Log assignment
        if (agent === 'carl') {
          log.carl(`${progress} Working on: ${story.name}`);
        } else if (agent === 'otto') {
          log.otto(`${progress} Working on: ${story.name}`);
        } else {
          log.larry(`${progress} Working on: ${story.name}`);
        }

        // Generate code
        const generated = generateMockCode(story.name, category);
        const fileName = `${toKebabCase(story.name)}.${generated.lang === 'dart' ? 'dart' : generated.lang === 'jsx' ? 'jsx' : 'js'}`;

        // Determine output path
        let outputPath;
        if (category === 'backend') {
          if (generated.type === 'test') {
            outputPath = path.join(outputDir, 'backend', 'tests', fileName);
          } else {
            outputPath = path.join(outputDir, 'backend', 'src', 'services', fileName);
          }
        } else if (category === 'frontend') {
          if (generated.type === 'hook') {
            outputPath = path.join(outputDir, 'frontend', 'src', 'hooks', fileName);
          } else {
            outputPath = path.join(outputDir, 'frontend', 'src', 'components', fileName);
          }
        } else if (category === 'mobile') {
          if (generated.type === 'provider') {
            outputPath = path.join(outputDir, 'mobile', 'lib', 'providers', fileName);
          } else {
            outputPath = path.join(outputDir, 'mobile', 'lib', 'widgets', fileName);
          }
        } else {
          outputPath = path.join(outputDir, 'backend', 'tests', fileName);
        }

        // Write file
        await fs.writeFile(outputPath, generated.code.trim());

        const lineCount = generated.code.split('\n').length;
        generationResults[category].files.push(fileName);
        generationResults[category].lines += lineCount;
        generationResults.total.files++;
        generationResults.total.lines += lineCount;

        log.file(`${fileName} (${lineCount} lines)`);

        // Publish code generated event
        eventBus.publish('CODE_GENERATED', {
          agent: agent,
          file: fileName,
          lines: lineCount,
          category: category
        });

      } catch (error) {
        log.error(`Failed to generate code for ${story.name}: ${error.message}`);
        generationResults.total.errors++;
      }

      console.log();
    }

    // Step 5: Validate generated code against architecture
    log.kevin('Vector! Run security checks on the generated code!');
    console.log();
    log.vector('Scanning generated code for security issues... OH YEAH!');

    // Simulate security scan
    const securityResults = {
      filesScanned: generationResults.total.files,
      issues: 0,
      warnings: 2, // Mock warnings
      passed: true
    };

    console.log(`${colors.bright}Security Scan Results:${colors.reset}`);
    console.log(`  - Files Scanned: ${securityResults.filesScanned}`);
    console.log(`  - Critical Issues: ${securityResults.issues}`);
    console.log(`  - Warnings: ${securityResults.warnings}`);
    console.log(`  - Status: ${securityResults.passed ? 'âœ… PASSED' : 'âŒ FAILED'}`);
    console.log();

    // Step 6: Store results in memory
    if (minions.memoryStore) {
      await minions.memoryStore.set('evolution', 'phase3-generation', generationResults);
      log.system('Generation results stored in memory');
    }

    // Step 7: Summary
    console.log(`${colors.yellow}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${colors.reset}`);
    console.log();

    console.log(`${colors.bright}Code Generation Summary:${colors.reset}`);
    console.log(`  - Stories Processed: ${processedCount}`);
    console.log(`  - Total Files Generated: ${generationResults.total.files}`);
    console.log(`  - Total Lines of Code: ${generationResults.total.lines}`);
    console.log(`  - Errors: ${generationResults.total.errors}`);
    console.log();

    console.log(`${colors.bright}By Category:${colors.reset}`);
    console.log(`  - Backend: ${generationResults.backend.files.length} files (${generationResults.backend.lines} lines)`);
    console.log(`  - Frontend: ${generationResults.frontend.files.length} files (${generationResults.frontend.lines} lines)`);
    console.log(`  - Mobile: ${generationResults.mobile.files.length} files (${generationResults.mobile.lines} lines)`);
    console.log(`  - Tests: ${generationResults.tests.files.length} files (${generationResults.tests.lines} lines)`);
    console.log();

    console.log(`${colors.bright}Generated Files Location:${colors.reset}`);
    console.log(`  ${outputDir}/`);
    console.log(`  â”œâ”€â”€ backend/`);
    console.log(`  â”‚   â”œâ”€â”€ src/services/`);
    console.log(`  â”‚   â”œâ”€â”€ src/controllers/`);
    console.log(`  â”‚   â””â”€â”€ tests/`);
    console.log(`  â”œâ”€â”€ frontend/`);
    console.log(`  â”‚   â””â”€â”€ src/components/`);
    console.log(`  â””â”€â”€ mobile/`);
    console.log(`      â””â”€â”€ lib/widgets/`);
    console.log();

    // Celebration
    console.log(`${colors.yellow}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${colors.reset}`);
    log.kevin('Phase 3 Complete! Code has been generated! BANANA! ğŸŒ');
    log.carl('*loud siren noises* The code is EFFICIENT!');
    log.otto('*adjusts braces* Mobile code is perfectly organized!');
    log.larry('*artistic flourish* The components are BEAUTIFUL!');
    log.vector('*parkour celebration* DIRECTION AND MAGNITUDE - Code is SECURE!');
    log.bob('*hugs teddy* We built something amazing!');
    log.stuart('*epic guitar solo* ğŸ¸ğŸ¸ğŸ¸');
    console.log(`${colors.yellow}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${colors.reset}`);
    console.log();

    console.log(`${colors.bright}Next Steps (Phase 4):${colors.reset}`);
    console.log(`  1. Run automated tests on generated code`);
    console.log(`  2. Fix any failing tests (Build â†’ Test â†’ Fix cycle)`);
    console.log(`  3. Integration testing across components`);
    console.log(`  4. Deploy Minions v3.0!`);
    console.log();

    // Cleanup
    log.system('Shutting down Minions...');
    if (minions.healthMonitor) minions.healthMonitor.stop();
    if (minions.metricsCollector) minions.metricsCollector.stop();
    if (minions.visionAgent) await minions.visionAgent.shutdown();
    if (minions.architectAgent) await minions.architectAgent.shutdown();
    if (minions.plannerAgent) await minions.plannerAgent.shutdown();

    log.success('Phase 3 complete. Minions signing off! ğŸŒ');
    process.exit(0);

  } catch (error) {
    log.error(`Phase 3 failed: ${error.message}`);
    console.error(error.stack);
    process.exit(1);
  }
}

// Run
main().catch(console.error);
